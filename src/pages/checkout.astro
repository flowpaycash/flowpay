---
import CheckoutLayout from "../layouts/CheckoutLayout.astro";
import CheckoutHeader from "../components/checkout/CheckoutHeader.astro";
import ModeChooser from "../components/checkout/ModeChooser.astro";
import PixForm from "../components/checkout/PixForm.astro";
import CryptoForm from "../components/checkout/CryptoForm.astro";
import StatusStepper from "../components/checkout/StatusStepper.astro";
---

<CheckoutLayout>
  <main class="checkout-main">
    <CheckoutHeader />

    <ModeChooser />

    <section class="flow-step" data-state="details" id="step-details" hidden>
      <PixForm />
      <CryptoForm />
    </section>

    <section class="flow-step" data-state="confirm" id="step-confirm" hidden>
      <StatusStepper />

      <div id="payment-area" class="payment-area">
        <!-- QR Code Container -->
        <div id="qr-container">
          <p id="qr-instruction" class="qr-instruction">
            Escaneie o QR Code para pagar
          </p>
          <div class="qr-wrapper">
            <img id="qr-image" src="" alt="QR Code PIX" class="qr-image" />
          </div>
          <div class="brcode-area">
            <input id="br-code-copy" readonly class="brcode-input" />
            <button
              class="text copy-btn"
              onclick="const e=document.getElementById('br-code-copy'); navigator.clipboard.writeText(e.value || e.innerText).then(() => alert('Código copiado!'))"
              >Copiar Código Pix</button
            >
          </div>
        </div>

        <!-- Processing State -->
        <div id="processing-state" hidden>
          <h3 class="gradient-text processing-title">Processando...</h3>
          <p class="processing-subtitle">
            A Smart Factory está validando sua transação.
          </p>
        </div>

        <!-- Final Success -->
        <div id="success-state" hidden>
          <h3 class="success-title">Ativo Emitido!</h3>
          <p class="success-subtitle">
            Sucesso. O ativo já está na sua carteira.
          </p>
          <div class="success-actions">
            <button class="primary" data-action="reset">Novo Pagamento</button>
          </div>
        </div>
      </div>
    </section>

    <footer class="checkout-footer">
      <p>&copy; 2026 FlowPay Sovereign Systems</p>
    </footer>
  </main>
</CheckoutLayout>

<style>
  .payment-area {
    text-align: center;
    margin-top: 2rem;
  }

  .qr-instruction {
    color: rgba(255, 255, 255, 0.7);
    margin-bottom: 1rem;
    font-size: 0.95rem;
  }

  .qr-wrapper {
    background: white;
    padding: 1rem;
    border-radius: 16px;
    display: inline-block;
    margin-bottom: 1rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  }

  .qr-image {
    width: 200px;
    height: 200px;
    display: block;
    border-radius: 8px;
  }

  .brcode-area {
    margin-top: 1rem;
  }

  .brcode-input {
    max-width: 100%;
    font-size: 0.85rem;
  }

  .copy-btn {
    margin-top: 0.5rem;
  }

  .processing-title {
    font-size: 1.5rem;
    font-weight: 700;
    animation: pulse 1.5s ease-in-out infinite;
  }

  .processing-subtitle {
    color: rgba(255, 255, 255, 0.6);
    margin-top: 0.5rem;
  }

  .success-title {
    color: #00ff88;
    font-size: 1.5rem;
    font-weight: 700;
    text-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
  }

  .success-subtitle {
    color: rgba(255, 255, 255, 0.7);
    margin-top: 0.5rem;
  }

  .success-actions {
    margin-top: 1.5rem;
  }

  .checkout-footer {
    text-align: center;
    margin-top: auto;
    padding-top: 2rem;
    padding-bottom: env(safe-area-inset-bottom, 16px);
    opacity: 0.3;
    font-size: 0.75rem;
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.6;
    }
    100% {
      opacity: 1;
    }
  }
</style>

<script is:inline type="module">
  import { startCheckout } from "/assets/js/navigation-flow.machine.js";

  document.addEventListener("DOMContentLoaded", async () => {
    // FLOWPay Sovereign UI initialized

    // Polling Control
    let pollInterval = null;
    const pollingArea = {
      qr: document.getElementById("qr-container"),
      proc: document.getElementById("processing-state"),
      success: document.getElementById("success-state"),
      qrImg: document.getElementById("qr-image"),
      brCopy: document.getElementById("br-code-copy"),
      steps: document.querySelectorAll(".step"),
    };

    function updateStepper(stepIndex) {
      pollingArea.steps.forEach((s, _i) => {
        const stepNum = parseInt(s.dataset.step);
        s.classList.toggle("done", stepNum < stepIndex);
        s.classList.toggle("active", stepNum === stepIndex);
      });
    }

    // Load copy
    let copy = {};
    try {
      const res = await fetch("/ui.copy.pt.json", { cache: "no-store" });
      if (res.ok) copy = await res.json();
    } catch (error) {
      // Copy loading failed silently
    }

    let svc = startCheckout({
      copy,
      services: {
        createPix: async (_ctx, p) => {
          const response = await fetch("/api/create-charge", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(p),
          });

          if (!response.ok) {
            const errData = await response.json();
            throw new Error(errData.error || "Erro ao criar PIX");
          }
          return await response.json();
        },
        submitCrypto: async (_ctx, p) => {
          if (window.__smartAccount && window.sendSATransaction) {
            try {
              const hash = await window.sendSATransaction({
                to: p.to,
                value: BigInt(p.amount * 10 ** 18),
              });
              return { success: true, hash };
            } catch (err) {
              console.error("Erro na transação Smart Account:", err);
              throw err;
            }
          }
          // Fallback ou modo manual
          return Promise.resolve({ success: true, hash: "0x..." });
        },
        connect: () => window.connectWallet?.(),
        disconnect: () => window.disconnectWallet?.(),
      },
      onToast: (_msg, _type) => {
        // Toast handled silently
      },
    });

    if (svc) {
      window.checkoutService = svc;
      svc.subscribe((state) => {
        const fill = document.getElementById("nf-fill");
        if (fill) {
          if (state.matches("choose")) fill.style.width = "33%";
          if (state.matches("details")) fill.style.width = "66%";
          if (state.matches("confirm")) fill.style.width = "100%";
        }

        if (state.matches("confirm")) {
          const data = state.context.lastResult;

          if (data && data.success && data.pix_data) {
            pollingArea.qr.hidden = false;
            pollingArea.proc.hidden = true;
            pollingArea.success.hidden = true;

            pollingArea.qrImg.src = data.pix_data.qr_code;
            pollingArea.brCopy.value = data.pix_data.br_code;

            updateStepper(1);

            if (!pollInterval) {
              // Polling started for charge
              pollInterval = setInterval(async () => {
                try {
                  const res = await fetch(`/api/charge/${data.id_transacao}`);
                  const statusData = await res.json();

                  if (
                    statusData.status === "PIX_PAID" ||
                    statusData.status === "PENDING_REVIEW"
                  ) {
                    pollingArea.qr.hidden = true;
                    pollingArea.proc.hidden = false;
                    updateStepper(2);

                    if (statusData.bridge_status === "SENT") {
                      updateStepper(3);
                    }
                  } else if (
                    statusData.status === "COMPLETED" ||
                    statusData.tx_hash
                  ) {
                    pollingArea.proc.hidden = true;
                    pollingArea.success.hidden = false;
                    updateStepper(4);

                    clearInterval(pollInterval);
                    pollInterval = null;
                  }
                } catch (e) {
                  // Poll error handled silently
                }
              }, 3000);
            }
          }
        } else {
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
          }
        }
      });
    }
  });
</script>
