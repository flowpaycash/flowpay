import{B as g,C as A,D as R,E as j,i as T,s as O,w as a,x as d,y as I,z as y}from"./chunk-W46MJTAP.js";import{a as N}from"./chunk-CRC5266G.js";import{c as u}from"./chunk-HUHSLM6Z.js";import{D as w,E as C,F as P,G as l,H as s,z as f}from"./chunk-MKYDMTOZ.js";import{a as c}from"./chunk-W44JATXS.js";var h=class extends y{async init(e){}async getIdentityToken(){if(!this.provider||this.status!==a.CONNECTED)throw s.notConnectedError();if(!this.coreOptions)throw l.invalidParams("Please initialize Web3Auth with valid options");let e=await this.provider.request({method:u.GET_ACCOUNTS});if(e&&e.length>0){let i=A(e[0],this.name);if(i&&!g(i))return{idToken:i};let t=await this.provider.request({method:"eth_chainId"}),r=this.coreOptions.chains.find(v=>v.chainId===t);if(!r)throw l.invalidParams("chainConfig is required before authentication");let{chainNamespace:o}=r,_={domain:window.location.origin,uri:window.location.href,address:e[0],chainId:parseInt(t,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:new Date().toISOString()},E=await w(_,o),q=`0x${Buffer.from(E,"utf8").toString("hex")}`,k=await this.provider.request({method:u.PERSONAL_SIGN,params:[q,e[0]]}),p=await C(o,k,E,this.name,this.coreOptions.sessionTime,this.coreOptions.clientId,this.coreOptions.web3AuthNetwork);return R(e[0],this.name,p),{idToken:p}}throw s.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnectSession(){super.checkDisconnectionRequirements();let e=await this.provider.request({method:"eth_accounts"});e&&e.length>0&&j(e[0],this.name)}async disconnect(){this.rehydrated=!1,this.emit(d.DISCONNECTED)}};var m=class extends h{constructor(e){super(e),c(this,"connectorNamespace",O.EIP155),c(this,"currentChainNamespace",f.EIP155),c(this,"type",I.EXTERNAL),c(this,"name",void 0),c(this,"isInjected",!0),c(this,"status",a.NOT_READY),c(this,"injectedProvider",null),this.name=e.name,this.injectedProvider=e.provider,this.icon=e.icon}get provider(){return this.status!==a.NOT_READY&&this.injectedProvider?this.injectedProvider:null}set provider(e){throw new Error("Not implemented")}async init(e){await super.init(e);let i=this.coreOptions.chains.find(t=>t.chainId===e.chainId);super.checkInitializationRequirements({chainConfig:i}),this.status=a.READY,this.emit(d.READY,this.name);try{if(N.debug(`initializing ${this.name} injected connector`),e.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:e.chainId})))throw this.rehydrated=!1,s.connectionError("Failed to rehydrate.")}catch(t){this.emit(d.REHYDRATION_ERROR,t)}}async connect({chainId:e}){if(super.checkConnectionRequirements(),!this.injectedProvider)throw s.connectionError("Injected provider is not available");let i=this.coreOptions.chains.find(t=>t.chainId===e);if(!i)throw s.connectionError("Chain config is not available");this.status=a.CONNECTING,this.emit(d.CONNECTING,{connector:this.name});try{if(await this.injectedProvider.request({method:"eth_requestAccounts"}),this.injectedProvider.chainId!==i.chainId)try{await this.switchChain(i,!0)}catch{await this.addChain(i,!0),await this.switchChain(i,!0)}this.status=a.CONNECTED;let t=r=>{if(r.length===0){var o;this.disconnect(),(o=this.injectedProvider)!==null&&o!==void 0&&o.removeListener&&this.injectedProvider.removeListener("accountsChanged",t)}};return this.injectedProvider.on("accountsChanged",t),this.emit(d.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.injectedProvider}),this.injectedProvider}catch(t){throw this.status=a.READY,this.rehydrated||this.emit(d.ERRORED,t),this.rehydrated=!1,t instanceof P?t:s.connectionError(`Failed to login with ${this.name} injected wallet`)}}async disconnect(e={cleanup:!1}){if(!this.injectedProvider)throw s.connectionError("Injected provider is not available");await super.disconnectSession(),typeof this.injectedProvider.removeAllListeners<"u"&&this.injectedProvider.removeAllListeners();try{await this.injectedProvider.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}e.cleanup?(this.status=a.NOT_READY,this.injectedProvider=null):this.status=a.READY,await super.disconnect()}async getUserInfo(){if(this.status!==a.CONNECTED)throw s.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(e,i=!1){if(!this.injectedProvider)throw s.connectionError("Injected provider is not available");await this.injectedProvider.request({method:"wallet_addEthereumChain",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorerUrl],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18},iconUrls:[e.logo]}]})}async switchChain(e,i=!1){if(!this.injectedProvider)throw s.connectionError("Injected provider is not available");super.checkSwitchChainRequirements(e,i),await this.injectedProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}async enableMFA(){throw new Error("Method Not implemented")}async manageMFA(){throw new Error("Method Not implemented")}},J=n=>({coreOptions:e})=>new m({name:T(n.info.name),provider:n.provider,icon:n.info.icon,coreOptions:e});function S(n){if(typeof window>"u")return;let e=i=>n(i.detail);return window.addEventListener("eip6963:announceProvider",e),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",e)}function x(){let n=new Set,e=[],i=()=>S(r=>{e.some(({info:o})=>o.uuid===r.info.uuid)||(e=[...e,r],n.forEach(o=>o(e,{added:[r]})))}),t=i();return{_listeners(){return n},clear(){n.forEach(r=>r([],{removed:[...e]})),e=[]},destroy(){this.clear(),n.clear(),t?.()},findProvider({rdns:r}){return e.find(o=>o.info.rdns===r)},getProviders(){return e},reset(){this.clear(),t?.(),t=i()},subscribe(r,{emitImmediately:o}={}){return n.add(r),o&&r(e,{added:e}),()=>n.delete(r)}}}export{h as a,J as b,x as c};
