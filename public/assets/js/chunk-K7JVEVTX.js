import{G as E,S as v,U as N,V as S,W as F,X as B,Y as I,Z as V,_ as W}from"./chunk-7WDLVTPT.js";import{c as D}from"./chunk-PO2OHKQD.js";import{a as U}from"./chunk-CRC5266G.js";import{G as H,o as P,p as w,q as k,r as h,s as x,u as O,z as L}from"./chunk-MKYDMTOZ.js";import{C as K,v as G}from"./chunk-GWB75M73.js";import{a as _,b as f}from"./chunk-W44JATXS.js";async function z({eoaProvider:i,handlers:t}){let[d]=await i.request({method:E.GET_ACCOUNTS});async function n(e,c){if(typeof e=="string"&&e.length>0){let g=(await t.getAccounts(c)).map(A=>A.toLowerCase()),m=e.toLowerCase();if(g.includes(m))return m}throw P.invalidParams({message:"Invalid parameters: must provide an Ethereum address."})}async function l(e,c){if(e.toLowerCase()===d.toLowerCase())return d;let[o]=await t.getAccounts(c);if(e.toLowerCase()===o.toLowerCase())return d;throw P.invalidParams({message:"Invalid parameters: must provide valid sender address."})}async function a(e,c){c.result=await t.getAccounts(e)}async function u(e,c){if(!t.getPrivateKey)throw P.methodNotSupported();c.result=await t.getPrivateKey(e)}async function r(e,c){if(!t.processTransaction)throw P.methodNotSupported();let o=e.params[0]||{from:""};o.from=await n(o.from,e),c.result=t.processTransaction(o,e)}async function p(e,c){let o=e.params[0]||{from:""};o.from&&(o.from=await l(o.from,e)),c.result=await t.processSignTransaction(o,e)}async function s(e,c){let o=e.params,g=e.params[2]||{};if(Array.isArray(e.params)){if(e.params.length!==2)throw new Error(`WalletMiddleware - incorrect params for ${e.method} method. expected [address, message]`);let m=e.params,A=m[0],M=m[1];o={from:A,data:M}}o=f(f({},g),o),c.result=await t.processEthSignMessage(o,e)}async function C(e,c){if(!(e!=null&&e.params))throw new Error("WalletMiddleware - missing params");let o=e.params;if(Array.isArray(e.params)){if(e.params.length!==2)throw new Error(`WalletMiddleware - incorrect params for ${e.method} method. expected [address, typedData]`);let g=e.params,m=g[0],A=g[1];o={from:m,data:A}}c.result=await t.processTypedMessageV4(o,e)}async function y(e,c){let o=e.params,g=e.params[2]||{};if(Array.isArray(e.params)){if(!(e.params.length>=2))throw new Error(`WalletMiddleware - incorrect params for ${e.method} method. expected [message, address]`);let m=e.params;if(typeof m[0]=="object"){let{challenge:A,address:M}=m[0];o={from:M,data:A}}else{let A=m[0];o={from:m[1],data:A}}}o=f(f({},g),o),c.result=await t.processPersonalMessage(o,e)}async function b(e,c){if(!t.getPublicKey)throw P.methodNotSupported();c.result=await t.getPublicKey(e)}return k({eth_accounts:h(a),eth_requestAccounts:h(a),eth_private_key:h(u),private_key:h(u),eth_public_key:h(b),public_key:h(b),eth_sendTransaction:h(r),eth_signTransaction:h(p),eth_sign:h(s),eth_signTypedData_v4:h(C),personal_sign:h(y)})}async function j({aaProvider:i}){async function t(n,l){let[,a]=await i.request({method:E.GET_ACCOUNTS});l.result=[a]}async function d(n,l){let[,a]=await i.request({method:E.ETH_REQUEST_ACCOUNTS});l.result=[a]}return k({eth_accounts:h(t),eth_requestAccounts:h(d)})}function R(i){return async(t,d,n,l)=>{try{let a=await i.request(t);return d.result=a,l()}catch(a){return l(a)}}}function Y({bundlerClient:i,smartAccount:t,chain:d,eoaProvider:n}){let l=I({account:t,chain:d,transport:S()});return{getAccounts:async a=>{let[u,r]=await Promise.all([t.getAddress(),n.request({method:"eth_accounts"})]);return U.info("smartAccounts",u),U.info("eoaAccounts",r),[u,...r]},getPrivateKey:async a=>{throw w.custom({message:"Smart accounts do not have private key",code:4903})},getPublicKey:async a=>{throw w.custom({message:"Smart accounts do not have a public key. Use address instead.",code:4903})},processTransaction:async a=>{a.input&&!a.data&&(a.data=K(a.input));let{to:u,value:r,data:p}=a,s={account:t,calls:[{to:u,value:BigInt(r),data:p}]},C=await i.sendUserOperation(s),y=await i.waitForUserOperationReceipt({hash:C});if(!y.success)throw w.custom({message:y.reason,code:4905});return y.receipt.transactionHash},processSignTransaction:async a=>{let{to:u,value:r,data:p}=a,s=await i.prepareUserOperation({account:t,calls:[{to:u,value:BigInt(r),data:p}]});return await t.signUserOperation({callData:s.callData,callGasLimit:s.callGasLimit,maxFeePerGas:s.maxFeePerGas,maxPriorityFeePerGas:s.maxPriorityFeePerGas,nonce:s.nonce,preVerificationGas:s.preVerificationGas,verificationGasLimit:s.verificationGasLimit,signature:s.signature})},processEthSignMessage:async(a,u)=>n.request(u),processPersonalMessage:async(a,u)=>{let r=a.data;return l.signMessage({account:t,message:G(r)?{raw:r}:r})},processTypedMessageV4:async(a,u)=>{try{let r=typeof a.data=="string"?JSON.parse(a.data):a.data;return await l.signTypedData({account:t,domain:f(f({},r.domain),{},{verifyingContract:r.domain.verifyingContract,salt:r.domain.salt,chainId:Number(r.domain.chainId)}),primaryType:r.primaryType,types:r.types,message:r.message})}catch(r){throw w.custom({message:r instanceof Error?r.message:"Failed to sign typed data",code:4905})}}}}var $,T=class extends D{constructor({config:t,state:d}){super({config:t,state:d}),_(this,"PROVIDER_CHAIN_NAMESPACE",L.EIP155),_(this,"_smartAccount",void 0),_(this,"_publicClient",void 0),_(this,"_bundlerClient",void 0),_(this,"_paymasterClient",void 0),_(this,"_useProviderAsTransport",void 0),this.update({chainId:t.chain.chainId})}get smartAccount(){return this._smartAccount}get bundlerClient(){return this._bundlerClient}get paymasterClient(){return this._paymasterClient}get publicClient(){return this._publicClient}async enable(){if(!this.state.eoaProvider)throw w.custom({message:"eoaProvider is not found in state, please pass it",code:4902});return await this.setupProvider(this.state.eoaProvider),this._providerEngineProxy.request({method:"eth_accounts"})}async setupProvider(t){var d;let{currentChain:n}=this,{chainNamespace:l}=n;if(l!==this.PROVIDER_CHAIN_NAMESPACE)throw H.incompatibleChainNameSpace("Invalid chain namespace");let a=this.config.smartAccountChainsConfig.find(m=>m.chainId===n.chainId);if(!a)throw H.invalidProviderConfigError(`Bundler and paymaster config not found for chain ${n.chainId}`);let{bundlerConfig:u,paymasterConfig:r}=a,p=F({id:Number.parseInt(n.chainId,16),name:n.displayName,rpcUrls:{default:{http:[n.rpcTarget],webSocket:[n.wsTarget]}},blockExplorers:n.blockExplorerUrl?{default:{name:"explorer",url:n.blockExplorerUrl}}:void 0,nativeCurrency:{name:n.tickerName,symbol:n.ticker,decimals:n.decimals||18}});this._publicClient=B({chain:p,transport:S(n.rpcTarget)});let[s]=await t.request({method:E.ETH_REQUEST_ACCOUNTS}),C=I({account:s,chain:p,transport:N(t)});if(this._smartAccount=await this.config.smartAccountInit.getSmartAccount({walletClient:C,client:this._publicClient}),r){var y;this._paymasterClient=W(f(f({},r),{},{transport:this._useProviderAsTransport?N(t):(y=r.transport)!==null&&y!==void 0?y:S(r.url)}))}this._bundlerClient=V(f(f({},u),{},{account:this.smartAccount,client:this._publicClient,transport:this._useProviderAsTransport?N(t):(d=u.transport)!==null&&d!==void 0?d:S(u.url),paymaster:this._paymasterClient}));let b=Y({bundlerClient:this._bundlerClient,smartAccount:this._smartAccount,chain:p,eoaProvider:t}),e=new x,c=await z({eoaProvider:t,handlers:b});e.push(c);let o=R(t);e.push(o);let g=O(e);this.updateProviderEngineProxy(g),t.once("chainChanged",m=>{this.update({chainId:m}),this.setupChainSwitchMiddleware(),this.emit("chainChanged",m)})}async updateAccount(t){throw w.unsupportedMethod("updateAccount. Please call it on eoaProvider")}async switchChain(t){throw w.unsupportedMethod("switchChain. Please call it on eoaProvider")}async lookupNetwork(){throw w.unsupportedMethod("lookupNetwork. Please call it on eoaProvider")}async setupChainSwitchMiddleware(){return this.setupProvider(this.state.eoaProvider)}};$=T;_(T,"getProviderInstance",async i=>{let t=new $({config:i});return t._useProviderAsTransport=i.useProviderAsTransport,await t.setupProvider(i.eoaProvider),t.update({eoaProvider:i.eoaProvider}),t});var gt=async({accountAbstractionConfig:i,chain:t,chains:d,provider:n,useProviderAsTransport:l})=>{let a,{smartAccountType:u,chains:r}=i,{smartAccountConfig:p}=r.find(s=>s.chainId===t.chainId)||{};switch(u){case v.BICONOMY:{let{BiconomySmartAccount:s}=await import("./lib-AKMBWPEW.js");a=new s(p);break}case v.KERNEL:{let{KernelSmartAccount:s}=await import("./lib-AKMBWPEW.js");a=new s(p);break}case v.NEXUS:{let{NexusSmartAccount:s}=await import("./lib-AKMBWPEW.js");a=new s(p);break}case v.SAFE:{let{SafeSmartAccount:s}=await import("./lib-AKMBWPEW.js");a=new s(p);break}case v.TRUST:{let{TrustSmartAccount:s}=await import("./lib-AKMBWPEW.js");a=new s(p);break}case v.METAMASK:{let{MetamaskSmartAccount:s}=await import("./lib-AKMBWPEW.js");a=new s(p);break}default:throw new Error("Smart account type not supported")}return T.getProviderInstance({eoaProvider:n,smartAccountInit:a,chain:t,chains:d,smartAccountChainsConfig:r,useProviderAsTransport:l})},wt=async i=>{let t=new x,d=await j({aaProvider:i});return t.push(d),t.push(R(i)),O(t)};export{gt as a,wt as b};
