import{a as St,c as le}from"./chunk-4H2HG446.js";import{a as ot,b as Mt,c as dt,d as ue,l as et,m as ht,n as st,p as H,s as mt}from"./chunk-E62CRSR5.js";var Yt=BigInt(0),jt=BigInt(1);function _t(t,n=""){if(typeof t!="boolean"){let r=n&&`"${n}"`;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function it(t,n,r=""){let e=ot(t),o=t?.length,s=n!==void 0;if(!e||s&&o!==n){let i=r&&`"${r}" `,f=s?` of length ${n}`:"",c=e?`length=${o}`:`type=${typeof t}`;throw new Error(i+"expected Uint8Array"+f+", got "+c)}return t}function Ot(t){let n=t.toString(16);return n.length&1?"0"+n:n}function de(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Yt:BigInt("0x"+t)}function J(t){return de(et(t))}function zt(t){return dt(t),de(et(Uint8Array.from(t).reverse()))}function pt(t,n){return ht(t.toString(16).padStart(n*2,"0"))}function Dt(t,n){return pt(t,n).reverse()}function C(t,n,r){let e;if(typeof n=="string")try{e=ht(n)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(ot(n))e=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");let o=e.length;if(typeof r=="number"&&o!==r)throw new Error(t+" of length "+r+" expected, got "+o);return e}var kt=t=>typeof t=="bigint"&&Yt<=t;function It(t,n,r){return kt(t)&&kt(n)&&kt(r)&&n<=t&&t<r}function he(t,n,r,e){if(!It(n,r,e))throw new Error("expected valid "+t+": "+r+" <= n < "+e+", got "+n)}function Ut(t){let n;for(n=0;t>Yt;t>>=jt,n+=1);return n}var ct=t=>(jt<<BigInt(t))-jt;function me(t,n,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let e=u=>new Uint8Array(u),o=u=>Uint8Array.of(u),s=e(t),i=e(t),f=0,c=()=>{s.fill(1),i.fill(0),f=0},d=(...u)=>r(i,s,...u),g=(u=e(0))=>{i=d(o(0),u),s=d(),u.length!==0&&(i=d(o(1),u),s=d())},b=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,w=[];for(;u<n;){s=d();let p=s.slice();w.push(p),u+=s.length}return H(...w)};return(u,w)=>{c(),g(u);let p;for(;!(p=w(b()));)g();return c(),p}}function ge(t){return typeof t=="function"&&Number.isSafeInteger(t.outputLen)}function gt(t,n,r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function e(o,s,i){let f=t[o];if(i&&f===void 0)return;let c=typeof f;if(c!==s||f===null)throw new Error(`param "${o}" is invalid: expected ${s}, got ${c}`)}Object.entries(n).forEach(([o,s])=>e(o,s,!1)),Object.entries(r).forEach(([o,s])=>e(o,s,!0))}function Xt(t){let n=new WeakMap;return(r,...e)=>{let o=n.get(r);if(o!==void 0)return o;let s=t(r,...e);return n.set(r,s),s}}var D=BigInt(0),j=BigInt(1),wt=BigInt(2),be=BigInt(3),pe=BigInt(4),Ee=BigInt(5),We=BigInt(7),xe=BigInt(8),Qe=BigInt(9),Be=BigInt(16);function z(t,n){let r=t%n;return r>=D?r:n+r}function P(t,n,r){let e=t;for(;n-- >D;)e*=e,e%=r;return e}function we(t,n){if(t===D)throw new Error("invert: expected non-zero number");if(n<=D)throw new Error("invert: expected positive modulus, got "+n);let r=z(t,n),e=n,o=D,s=j,i=j,f=D;for(;r!==D;){let d=e/r,g=e%r,b=o-i*d,a=s-f*d;e=r,r=g,o=i,s=f,i=b,f=a}if(e!==j)throw new Error("invert: does not exist");return z(o,n)}function $t(t,n,r){if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root")}function ve(t,n){let r=(t.ORDER+j)/pe,e=t.pow(n,r);return $t(t,e,n),e}function Je(t,n){let r=(t.ORDER-Ee)/xe,e=t.mul(n,wt),o=t.pow(e,r),s=t.mul(n,o),i=t.mul(t.mul(s,wt),o),f=t.mul(s,t.sub(i,t.ONE));return $t(t,f,n),f}function Fe(t){let n=ft(t),r=Se(t),e=r(n,n.neg(n.ONE)),o=r(n,e),s=r(n,n.neg(e)),i=(t+We)/Be;return(f,c)=>{let d=f.pow(c,i),g=f.mul(d,e),b=f.mul(d,o),a=f.mul(d,s),u=f.eql(f.sqr(g),c),w=f.eql(f.sqr(b),c);d=f.cmov(d,g,u),g=f.cmov(a,b,w);let p=f.eql(f.sqr(g),c),S=f.cmov(d,g,p);return $t(f,S,c),S}}function Se(t){if(t<be)throw new Error("sqrt is not defined for small field");let n=t-j,r=0;for(;n%wt===D;)n/=wt,r++;let e=wt,o=ft(t);for(;ye(o,e)===1;)if(e++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return ve;let s=o.pow(e,n),i=(n+j)/wt;return function(c,d){if(c.is0(d))return d;if(ye(c,d)!==1)throw new Error("Cannot find square root");let g=r,b=c.mul(c.ONE,s),a=c.pow(d,n),u=c.pow(d,i);for(;!c.eql(a,c.ONE);){if(c.is0(a))return c.ZERO;let w=1,p=c.sqr(a);for(;!c.eql(p,c.ONE);)if(w++,p=c.sqr(p),w===g)throw new Error("Cannot find square root");let S=j<<BigInt(g-w-1),O=c.pow(b,S);g=w,b=c.sqr(O),a=c.mul(a,b),u=c.mul(u,O)}return u}}function tn(t){return t%pe===be?ve:t%xe===Ee?Je:t%Be===Qe?Fe(t):Se(t)}var en=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Zt(t){let n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=en.reduce((e,o)=>(e[o]="function",e),n);return gt(t,r),t}function nn(t,n,r){if(r<D)throw new Error("invalid exponent, negatives unsupported");if(r===D)return t.ONE;if(r===j)return n;let e=t.ONE,o=n;for(;r>D;)r&j&&(e=t.mul(e,o)),o=t.sqr(o),r>>=j;return e}function yt(t,n,r=!1){let e=new Array(n.length).fill(r?t.ZERO:void 0),o=n.reduce((i,f,c)=>t.is0(f)?i:(e[c]=i,t.mul(i,f)),t.ONE),s=t.inv(o);return n.reduceRight((i,f,c)=>t.is0(f)?i:(e[c]=t.mul(i,e[c]),t.mul(i,f)),s),e}function ye(t,n){let r=(t.ORDER-j)/wt,e=t.pow(n,r),o=t.eql(e,t.ONE),s=t.eql(e,t.ZERO),i=t.eql(e,t.neg(t.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function Vt(t,n){n!==void 0&&Mt(n);let r=n!==void 0?n:t.toString(2).length,e=Math.ceil(r/8);return{nBitLength:r,nByteLength:e}}function ft(t,n,r=!1,e={}){if(t<=D)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,s,i=!1,f;if(typeof n=="object"&&n!=null){if(e.sqrt||r)throw new Error("cannot specify opts in two arguments");let a=n;a.BITS&&(o=a.BITS),a.sqrt&&(s=a.sqrt),typeof a.isLE=="boolean"&&(r=a.isLE),typeof a.modFromBytes=="boolean"&&(i=a.modFromBytes),f=a.allowedLengths}else typeof n=="number"&&(o=n),e.sqrt&&(s=e.sqrt);let{nBitLength:c,nByteLength:d}=Vt(t,o);if(d>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let g,b=Object.freeze({ORDER:t,isLE:r,BITS:c,BYTES:d,MASK:ct(c),ZERO:D,ONE:j,allowedLengths:f,create:a=>z(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return D<=a&&a<t},is0:a=>a===D,isValidNot0:a=>!b.is0(a)&&b.isValid(a),isOdd:a=>(a&j)===j,neg:a=>z(-a,t),eql:(a,u)=>a===u,sqr:a=>z(a*a,t),add:(a,u)=>z(a+u,t),sub:(a,u)=>z(a-u,t),mul:(a,u)=>z(a*u,t),pow:(a,u)=>nn(b,a,u),div:(a,u)=>z(a*we(u,t),t),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>we(a,t),sqrt:s||(a=>(g||(g=tn(t)),g(b,a))),toBytes:a=>r?Dt(a,d):pt(a,d),fromBytes:(a,u=!0)=>{if(f){if(!f.includes(a.length)||a.length>d)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+a.length);let p=new Uint8Array(d);p.set(a,r?0:p.length-a.length),a=p}if(a.length!==d)throw new Error("Field.fromBytes: expected "+d+" bytes, got "+a.length);let w=r?zt(a):J(a);if(i&&(w=z(w,t)),!u&&!b.isValid(w))throw new Error("invalid field element: outside of range 0..ORDER");return w},invertBatch:a=>yt(b,a),cmov:(a,u,w)=>w?u:a});return Object.freeze(b)}function _e(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let n=t.toString(2).length;return Math.ceil(n/8)}function Pt(t){let n=_e(t);return n+Math.ceil(n/2)}function Lt(t,n,r=!1){let e=t.length,o=_e(n),s=Pt(n);if(e<16||e<s||e>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+e);let i=r?zt(t):J(t),f=z(i,n-j)+j;return r?Dt(f,o):pt(f,o)}var Et=BigInt(0),bt=BigInt(1);function Rt(t,n){let r=n.negate();return t?r:n}function Ht(t,n){let r=yt(t.Fp,n.map(e=>e.Z));return n.map((e,o)=>t.fromAffine(e.toAffine(r[o])))}function qe(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Gt(t,n){qe(t,n);let r=Math.ceil(n/t)+1,e=2**(t-1),o=2**t,s=ct(t),i=BigInt(t);return{windows:r,windowSize:e,mask:s,maxNumber:o,shiftBy:i}}function Oe(t,n,r){let{windowSize:e,mask:o,maxNumber:s,shiftBy:i}=r,f=Number(t&o),c=t>>i;f>e&&(f-=s,c+=bt);let d=n*e,g=d+Math.abs(f)-1,b=f===0,a=f<0,u=n%2!==0;return{nextN:c,offset:g,isZero:b,isNeg:a,isNegF:u,offsetF:d}}function rn(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,e)=>{if(!(r instanceof n))throw new Error("invalid point at index "+e)})}function on(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,e)=>{if(!n.isValid(r))throw new Error("invalid scalar at index "+e)})}var Wt=new WeakMap,Ae=new WeakMap;function Qt(t){return Ae.get(t)||1}function Ie(t){if(t!==Et)throw new Error("invalid wNAF")}var Ct=class{constructor(n,r){this.BASE=n.BASE,this.ZERO=n.ZERO,this.Fn=n.Fn,this.bits=r}_unsafeLadder(n,r,e=this.ZERO){let o=n;for(;r>Et;)r&bt&&(e=e.add(o)),o=o.double(),r>>=bt;return e}precomputeWindow(n,r){let{windows:e,windowSize:o}=Gt(r,this.bits),s=[],i=n,f=i;for(let c=0;c<e;c++){f=i,s.push(f);for(let d=1;d<o;d++)f=f.add(i),s.push(f);i=f.double()}return s}wNAF(n,r,e){if(!this.Fn.isValid(e))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE,i=Gt(n,this.bits);for(let f=0;f<i.windows;f++){let{nextN:c,offset:d,isZero:g,isNeg:b,isNegF:a,offsetF:u}=Oe(e,f,i);e=c,g?s=s.add(Rt(a,r[u])):o=o.add(Rt(b,r[d]))}return Ie(e),{p:o,f:s}}wNAFUnsafe(n,r,e,o=this.ZERO){let s=Gt(n,this.bits);for(let i=0;i<s.windows&&e!==Et;i++){let{nextN:f,offset:c,isZero:d,isNeg:g}=Oe(e,i,s);if(e=f,!d){let b=r[c];o=o.add(g?b.negate():b)}}return Ie(e),o}getPrecomputes(n,r,e){let o=Wt.get(r);return o||(o=this.precomputeWindow(r,n),n!==1&&(typeof e=="function"&&(o=e(o)),Wt.set(r,o))),o}cached(n,r,e){let o=Qt(n);return this.wNAF(o,this.getPrecomputes(o,n,e),r)}unsafe(n,r,e,o){let s=Qt(n);return s===1?this._unsafeLadder(n,r,o):this.wNAFUnsafe(s,this.getPrecomputes(s,n,e),r,o)}createCache(n,r){qe(r,this.bits),Ae.set(n,r),Wt.delete(n)}hasCache(n){return Qt(n)!==1}};function Ne(t,n,r,e){let o=n,s=t.ZERO,i=t.ZERO;for(;r>Et||e>Et;)r&bt&&(s=s.add(o)),e&bt&&(i=i.add(o)),o=o.double(),r>>=bt,e>>=bt;return{p1:s,p2:i}}function Te(t,n,r,e){rn(r,t),on(e,n);let o=r.length,s=e.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");let i=t.ZERO,f=Ut(BigInt(o)),c=1;f>12?c=f-3:f>4?c=f-2:f>0&&(c=2);let d=ct(c),g=new Array(Number(d)+1).fill(i),b=Math.floor((n.BITS-1)/c)*c,a=i;for(let u=b;u>=0;u-=c){g.fill(i);for(let p=0;p<s;p++){let S=e[p],O=Number(S>>BigInt(u)&d);g[O]=g[O].add(r[p])}let w=i;for(let p=g.length-1,S=i;p>0;p--)S=S.add(g[p]),w=w.add(S);if(a=a.add(w),u!==0)for(let p=0;p<c;p++)a=a.double()}return a}function Re(t,n,r){if(n){if(n.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Zt(n),n}else return ft(t,{isLE:r})}function Ue(t,n,r={},e){if(e===void 0&&(e=t==="edwards"),!n||typeof n!="object")throw new Error(`expected valid ${t} CURVE object`);for(let c of["p","n","h"]){let d=n[c];if(!(typeof d=="bigint"&&d>Et))throw new Error(`CURVE.${c} must be positive bigint`)}let o=Re(n.p,r.Fp,e),s=Re(n.n,r.Fn,e),f=["Gx","Gy","a",t==="weierstrass"?"b":"d"];for(let c of f)if(!o.isValid(n[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return n=Object.freeze(Object.assign({},n)),{CURVE:n,Fp:o,Fn:s}}var Ze=(t,n)=>(t+(t>=0?n:-n)/tt)/n;function sn(t,n,r){let[[e,o],[s,i]]=n,f=Ze(i*t,r),c=Ze(-o*t,r),d=t-f*e-c*s,g=-f*o-c*i,b=d<F,a=g<F;b&&(d=-d),a&&(g=-g);let u=ct(Math.ceil(Ut(r)/2))+Y;if(d<F||d>=u||g<F||g>=u)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:b,k1:d,k2neg:a,k2:g}}function Ft(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function Jt(t,n){let r={};for(let e of Object.keys(n))r[e]=t[e]===void 0?n[e]:t[e];return _t(r.lowS,"lowS"),_t(r.prehash,"prehash"),r.format!==void 0&&Ft(r.format),r}var te=class extends Error{constructor(n=""){super(n)}},nt={Err:te,_tlv:{encode:(t,n)=>{let{Err:r}=nt;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length&1)throw new r("tlv.encode: unpadded data");let e=n.length/2,o=Ot(e);if(o.length/2&128)throw new r("tlv.encode: long form length too big");let s=e>127?Ot(o.length/2|128):"";return Ot(t)+s+o+n},decode(t,n){let{Err:r}=nt,e=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length<2||n[e++]!==t)throw new r("tlv.decode: wrong tlv");let o=n[e++],s=!!(o&128),i=0;if(!s)i=o;else{let c=o&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");let d=n.subarray(e,e+c);if(d.length!==c)throw new r("tlv.decode: length bytes not complete");if(d[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(let g of d)i=i<<8|g;if(e+=c,i<128)throw new r("tlv.decode(long): not minimal encoding")}let f=n.subarray(e,e+i);if(f.length!==i)throw new r("tlv.decode: wrong value length");return{v:f,l:n.subarray(e+i)}}},_int:{encode(t){let{Err:n}=nt;if(t<F)throw new n("integer: negative integers are not allowed");let r=Ot(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return r},decode(t){let{Err:n}=nt;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return J(t)}},toSig(t){let{Err:n,_int:r,_tlv:e}=nt,o=C("signature",t),{v:s,l:i}=e.decode(48,o);if(i.length)throw new n("invalid signature: left bytes after parsing");let{v:f,l:c}=e.decode(2,s),{v:d,l:g}=e.decode(2,c);if(g.length)throw new n("invalid signature: left bytes after parsing");return{r:r.decode(f),s:r.decode(d)}},hexFromSig(t){let{_tlv:n,_int:r}=nt,e=n.encode(2,r.encode(t.r)),o=n.encode(2,r.encode(t.s)),s=e+o;return n.encode(48,s)}},F=BigInt(0),Y=BigInt(1),tt=BigInt(2),xt=BigInt(3),ee=BigInt(4);function at(t,n){let{BYTES:r}=t,e;if(typeof n=="bigint")e=n;else{let o=C("private key",n);try{e=t.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof n}`)}}if(!t.isValidNot0(e))throw new Error("invalid private key: out of range [1..N-1]");return e}function cn(t,n={}){let r=Ue("weierstrass",t,n),{Fp:e,Fn:o}=r,s=r.CURVE,{h:i,n:f}=s;gt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});let{endo:c}=n;if(c&&(!e.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');let d=Ce(e,o);function g(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function b(N,m,h){let{x:l,y}=m.toAffine(),E=e.toBytes(l);if(_t(h,"isCompressed"),h){g();let v=!e.isOdd(y);return H(Ve(v),E)}else return H(Uint8Array.of(4),E,e.toBytes(y))}function a(N){it(N,void 0,"Point");let{publicKey:m,publicKeyUncompressed:h}=d,l=N.length,y=N[0],E=N.subarray(1);if(l===m&&(y===2||y===3)){let v=e.fromBytes(E);if(!e.isValid(v))throw new Error("bad point: is not on curve, wrong x");let B=p(v),x;try{x=e.sqrt(B)}catch(K){let U=K instanceof Error?": "+K.message:"";throw new Error("bad point: is not on curve, sqrt error"+U)}g();let _=e.isOdd(x);return(y&1)===1!==_&&(x=e.neg(x)),{x:v,y:x}}else if(l===h&&y===4){let v=e.BYTES,B=e.fromBytes(E.subarray(0,v)),x=e.fromBytes(E.subarray(v,v*2));if(!S(B,x))throw new Error("bad point: is not on curve");return{x:B,y:x}}else throw new Error(`bad point: got length ${l}, expected compressed=${m} or uncompressed=${h}`)}let u=n.toBytes||b,w=n.fromBytes||a;function p(N){let m=e.sqr(N),h=e.mul(m,N);return e.add(e.add(h,e.mul(N,s.a)),s.b)}function S(N,m){let h=e.sqr(m),l=p(N);return e.eql(h,l)}if(!S(s.Gx,s.Gy))throw new Error("bad curve params: generator point");let O=e.mul(e.pow(s.a,xt),ee),T=e.mul(e.sqr(s.b),BigInt(27));if(e.is0(e.add(O,T)))throw new Error("bad curve params: a or b");function q(N,m,h=!1){if(!e.isValid(m)||h&&e.is0(m))throw new Error(`bad point coordinate ${N}`);return m}function Z(N){if(!(N instanceof R))throw new Error("ProjectivePoint expected")}function X(N){if(!c||!c.basises)throw new Error("no endo");return sn(N,c.basises,o.ORDER)}let G=Xt((N,m)=>{let{X:h,Y:l,Z:y}=N;if(e.eql(y,e.ONE))return{x:h,y:l};let E=N.is0();m==null&&(m=E?e.ONE:e.inv(y));let v=e.mul(h,m),B=e.mul(l,m),x=e.mul(y,m);if(E)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:v,y:B}}),Q=Xt(N=>{if(N.is0()){if(n.allowInfinityPoint&&!e.is0(N.Y))return;throw new Error("bad point: ZERO")}let{x:m,y:h}=N.toAffine();if(!e.isValid(m)||!e.isValid(h))throw new Error("bad point: x or y not field elements");if(!S(m,h))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function W(N,m,h,l,y){return h=new R(e.mul(h.X,N),h.Y,h.Z),m=Rt(l,m),h=Rt(y,h),m.add(h)}class R{constructor(m,h,l){this.X=q("x",m),this.Y=q("y",h,!0),this.Z=q("z",l),Object.freeze(this)}static CURVE(){return s}static fromAffine(m){let{x:h,y:l}=m||{};if(!m||!e.isValid(h)||!e.isValid(l))throw new Error("invalid affine point");if(m instanceof R)throw new Error("projective point not allowed");return e.is0(h)&&e.is0(l)?R.ZERO:new R(h,l,e.ONE)}static fromBytes(m){let h=R.fromAffine(w(it(m,void 0,"point")));return h.assertValidity(),h}static fromHex(m){return R.fromBytes(C("pointHex",m))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(m=8,h=!0){return lt.createCache(this,m),h||this.multiply(xt),this}assertValidity(){Q(this)}hasEvenY(){let{y:m}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(m)}equals(m){Z(m);let{X:h,Y:l,Z:y}=this,{X:E,Y:v,Z:B}=m,x=e.eql(e.mul(h,B),e.mul(E,y)),_=e.eql(e.mul(l,B),e.mul(v,y));return x&&_}negate(){return new R(this.X,e.neg(this.Y),this.Z)}double(){let{a:m,b:h}=s,l=e.mul(h,xt),{X:y,Y:E,Z:v}=this,B=e.ZERO,x=e.ZERO,_=e.ZERO,I=e.mul(y,y),K=e.mul(E,E),U=e.mul(v,v),A=e.mul(y,E);return A=e.add(A,A),_=e.mul(y,v),_=e.add(_,_),B=e.mul(m,_),x=e.mul(l,U),x=e.add(B,x),B=e.sub(K,x),x=e.add(K,x),x=e.mul(B,x),B=e.mul(A,B),_=e.mul(l,_),U=e.mul(m,U),A=e.sub(I,U),A=e.mul(m,A),A=e.add(A,_),_=e.add(I,I),I=e.add(_,I),I=e.add(I,U),I=e.mul(I,A),x=e.add(x,I),U=e.mul(E,v),U=e.add(U,U),I=e.mul(U,A),B=e.sub(B,I),_=e.mul(U,K),_=e.add(_,_),_=e.add(_,_),new R(B,x,_)}add(m){Z(m);let{X:h,Y:l,Z:y}=this,{X:E,Y:v,Z:B}=m,x=e.ZERO,_=e.ZERO,I=e.ZERO,K=s.a,U=e.mul(s.b,xt),A=e.mul(h,E),V=e.mul(l,v),M=e.mul(y,B),$=e.add(h,l),L=e.add(E,v);$=e.mul($,L),L=e.add(A,V),$=e.sub($,L),L=e.add(h,y);let k=e.add(E,B);return L=e.mul(L,k),k=e.add(A,M),L=e.sub(L,k),k=e.add(l,y),x=e.add(v,B),k=e.mul(k,x),x=e.add(V,M),k=e.sub(k,x),I=e.mul(K,L),x=e.mul(U,M),I=e.add(x,I),x=e.sub(V,I),I=e.add(V,I),_=e.mul(x,I),V=e.add(A,A),V=e.add(V,A),M=e.mul(K,M),L=e.mul(U,L),V=e.add(V,M),M=e.sub(A,M),M=e.mul(K,M),L=e.add(L,M),A=e.mul(V,L),_=e.add(_,A),A=e.mul(k,L),x=e.mul($,x),x=e.sub(x,A),A=e.mul($,V),I=e.mul(k,I),I=e.add(I,A),new R(x,_,I)}subtract(m){return this.add(m.negate())}is0(){return this.equals(R.ZERO)}multiply(m){let{endo:h}=n;if(!o.isValidNot0(m))throw new Error("invalid scalar: out of range");let l,y,E=v=>lt.cached(this,v,B=>Ht(R,B));if(h){let{k1neg:v,k1:B,k2neg:x,k2:_}=X(m),{p:I,f:K}=E(B),{p:U,f:A}=E(_);y=K.add(A),l=W(h.beta,I,U,v,x)}else{let{p:v,f:B}=E(m);l=v,y=B}return Ht(R,[l,y])[0]}multiplyUnsafe(m){let{endo:h}=n,l=this;if(!o.isValid(m))throw new Error("invalid scalar: out of range");if(m===F||l.is0())return R.ZERO;if(m===Y)return l;if(lt.hasCache(this))return this.multiply(m);if(h){let{k1neg:y,k1:E,k2neg:v,k2:B}=X(m),{p1:x,p2:_}=Ne(R,l,E,B);return W(h.beta,x,_,y,v)}else return lt.unsafe(l,m)}multiplyAndAddUnsafe(m,h,l){let y=this.multiplyUnsafe(h).add(m.multiplyUnsafe(l));return y.is0()?void 0:y}toAffine(m){return G(this,m)}isTorsionFree(){let{isTorsionFree:m}=n;return i===Y?!0:m?m(R,this):lt.unsafe(this,f).is0()}clearCofactor(){let{clearCofactor:m}=n;return i===Y?this:m?m(R,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(m=!0){return _t(m,"isCompressed"),this.assertValidity(),u(R,this,m)}toHex(m=!0){return et(this.toBytes(m))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(m=!0){return this.toBytes(m)}_setWindowSize(m){this.precompute(m)}static normalizeZ(m){return Ht(R,m)}static msm(m,h){return Te(R,o,m,h)}static fromPrivateKey(m){return R.BASE.multiply(at(o,m))}}R.BASE=new R(s.Gx,s.Gy,e.ONE),R.ZERO=new R(e.ZERO,e.ONE,e.ZERO),R.Fp=e,R.Fn=o;let Nt=o.BITS,lt=new Ct(R,n.endo?Math.ceil(Nt/2):Nt);return R.BASE.precompute(8),R}function Ve(t){return Uint8Array.of(t?2:3)}function fn(t,n){let r=t.ORDER,e=F;for(let w=r-Y;w%tt===F;w/=tt)e+=Y;let o=e,s=tt<<o-Y-Y,i=s*tt,f=(r-Y)/i,c=(f-Y)/tt,d=i-Y,g=s,b=t.pow(n,f),a=t.pow(n,(f+Y)/tt),u=(w,p)=>{let S=b,O=t.pow(p,d),T=t.sqr(O);T=t.mul(T,p);let q=t.mul(w,T);q=t.pow(q,c),q=t.mul(q,O),O=t.mul(q,p),T=t.mul(q,w);let Z=t.mul(T,O);q=t.pow(Z,g);let X=t.eql(q,t.ONE);O=t.mul(T,a),q=t.mul(Z,S),T=t.cmov(O,T,X),Z=t.cmov(q,Z,X);for(let G=o;G>Y;G--){let Q=G-tt;Q=tt<<Q-Y;let W=t.pow(Z,Q),R=t.eql(W,t.ONE);O=t.mul(T,S),S=t.mul(S,S),W=t.mul(Z,S),T=t.cmov(O,T,R),Z=t.cmov(W,Z,R)}return{isValid:X,value:T}};if(t.ORDER%ee===xt){let w=(t.ORDER-xt)/ee,p=t.sqrt(t.neg(n));u=(S,O)=>{let T=t.sqr(O),q=t.mul(S,O);T=t.mul(T,q);let Z=t.pow(T,w);Z=t.mul(Z,q);let X=t.mul(Z,p),G=t.mul(t.sqr(Z),O),Q=t.eql(G,S),W=t.cmov(X,Z,Q);return{isValid:Q,value:W}}}return u}function Le(t,n){Zt(t);let{A:r,B:e,Z:o}=n;if(!t.isValid(r)||!t.isValid(e)||!t.isValid(o))throw new Error("mapToCurveSimpleSWU: invalid opts");let s=fn(t,o);if(!t.isOdd)throw new Error("Field does not have .isOdd()");return i=>{let f,c,d,g,b,a,u,w;f=t.sqr(i),f=t.mul(f,o),c=t.sqr(f),c=t.add(c,f),d=t.add(c,t.ONE),d=t.mul(d,e),g=t.cmov(o,t.neg(c),!t.eql(c,t.ZERO)),g=t.mul(g,r),c=t.sqr(d),a=t.sqr(g),b=t.mul(a,r),c=t.add(c,b),c=t.mul(c,d),a=t.mul(a,g),b=t.mul(a,e),c=t.add(c,b),u=t.mul(f,d);let{isValid:p,value:S}=s(c,a);w=t.mul(f,i),w=t.mul(w,S),u=t.cmov(u,d,p),w=t.cmov(w,S,p);let O=t.isOdd(i)===t.isOdd(w);w=t.cmov(t.neg(w),w,O);let T=yt(t,[g],!0)[0];return u=t.mul(u,T),{x:u,y:w}}}function Ce(t,n){return{secretKey:n.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*n.BYTES}}function an(t,n={}){let{Fn:r}=t,e=n.randomBytes||mt,o=Object.assign(Ce(t.Fp,r),{seed:Pt(r.ORDER)});function s(u){try{return!!at(r,u)}catch{return!1}}function i(u,w){let{publicKey:p,publicKeyUncompressed:S}=o;try{let O=u.length;return w===!0&&O!==p||w===!1&&O!==S?!1:!!t.fromBytes(u)}catch{return!1}}function f(u=e(o.seed)){return Lt(it(u,o.seed,"seed"),r.ORDER)}function c(u,w=!0){return t.BASE.multiply(at(r,u)).toBytes(w)}function d(u){let w=f(u);return{secretKey:w,publicKey:c(w)}}function g(u){if(typeof u=="bigint")return!1;if(u instanceof t)return!0;let{secretKey:w,publicKey:p,publicKeyUncompressed:S}=o;if(r.allowedLengths||w===p)return;let O=C("key",u).length;return O===p||O===S}function b(u,w,p=!0){if(g(u)===!0)throw new Error("first arg must be private key");if(g(w)===!1)throw new Error("second arg must be public key");let S=at(r,u);return t.fromHex(w).multiply(S).toBytes(p)}return Object.freeze({getPublicKey:c,getSharedSecret:b,keygen:d,Point:t,utils:{isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:f,isValidPrivateKey:s,randomPrivateKey:f,normPrivateKeyToScalar:u=>at(r,u),precompute(u=8,w=t.BASE){return w.precompute(u,!1)}},lengths:o})}function un(t,n,r={}){ue(n),gt(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let e=r.randomBytes||mt,o=r.hmac||((h,...l)=>le(n,h,H(...l))),{Fp:s,Fn:i}=t,{ORDER:f,BITS:c}=i,{keygen:d,getPublicKey:g,getSharedSecret:b,utils:a,lengths:u}=an(t,r),w={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},p="compact";function S(h){let l=f>>Y;return h>l}function O(h,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${h}: out of range 1..Point.Fn.ORDER`);return l}function T(h,l){Ft(l);let y=u.signature,E=l==="compact"?y:l==="recovered"?y+1:void 0;return it(h,E,`${l} signature`)}class q{constructor(l,y,E){this.r=O("r",l),this.s=O("s",y),E!=null&&(this.recovery=E),Object.freeze(this)}static fromBytes(l,y=p){T(l,y);let E;if(y==="der"){let{r:_,s:I}=nt.toSig(it(l));return new q(_,I)}y==="recovered"&&(E=l[0],y="compact",l=l.subarray(1));let v=i.BYTES,B=l.subarray(0,v),x=l.subarray(v,v*2);return new q(i.fromBytes(B),i.fromBytes(x),E)}static fromHex(l,y){return this.fromBytes(ht(l),y)}addRecoveryBit(l){return new q(this.r,this.s,l)}recoverPublicKey(l){let y=s.ORDER,{r:E,s:v,recovery:B}=this;if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");if(f*tt<y&&B>1)throw new Error("recovery id is ambiguous for h>1 curve");let _=B===2||B===3?E+f:E;if(!s.isValid(_))throw new Error("recovery id 2 or 3 invalid");let I=s.toBytes(_),K=t.fromBytes(H(Ve((B&1)===0),I)),U=i.inv(_),A=X(C("msgHash",l)),V=i.create(-A*U),M=i.create(v*U),$=t.BASE.multiplyUnsafe(V).add(K.multiplyUnsafe(M));if($.is0())throw new Error("point at infinify");return $.assertValidity(),$}hasHighS(){return S(this.s)}toBytes(l=p){if(Ft(l),l==="der")return ht(nt.hexFromSig(this));let y=i.toBytes(this.r),E=i.toBytes(this.s);if(l==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return H(Uint8Array.of(this.recovery),y,E)}return H(y,E)}toHex(l){return et(this.toBytes(l))}assertValidity(){}static fromCompact(l){return q.fromBytes(C("sig",l),"compact")}static fromDER(l){return q.fromBytes(C("sig",l),"der")}normalizeS(){return this.hasHighS()?new q(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return et(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return et(this.toBytes("compact"))}}let Z=r.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");let y=J(l),E=l.length*8-c;return E>0?y>>BigInt(E):y},X=r.bits2int_modN||function(l){return i.create(Z(l))},G=ct(c);function Q(h){return he("num < 2^"+c,h,F,G),i.toBytes(h)}function W(h,l){return it(h,void 0,"message"),l?it(n(h),void 0,"prehashed message"):h}function R(h,l,y){if(["recovered","canonical"].some(V=>V in y))throw new Error("sign() legacy options not supported");let{lowS:E,prehash:v,extraEntropy:B}=Jt(y,w);h=W(h,v);let x=X(h),_=at(i,l),I=[Q(_),Q(x)];if(B!=null&&B!==!1){let V=B===!0?e(u.secretKey):B;I.push(C("extraEntropy",V))}let K=H(...I),U=x;function A(V){let M=Z(V);if(!i.isValidNot0(M))return;let $=i.inv(M),L=t.BASE.multiply(M).toAffine(),k=i.create(L.x);if(k===F)return;let Tt=i.create($*i.create(U+k*_));if(Tt===F)return;let fe=(L.x===k?0:2)|Number(L.y&Y),ae=Tt;return E&&S(Tt)&&(ae=i.neg(Tt),fe^=1),new q(k,ae,fe)}return{seed:K,k2sig:A}}function Nt(h,l,y={}){h=C("message",h);let{seed:E,k2sig:v}=R(h,l,y);return me(n.outputLen,i.BYTES,o)(E,v)}function lt(h){let l,y=typeof h=="string"||ot(h),E=!y&&h!==null&&typeof h=="object"&&typeof h.r=="bigint"&&typeof h.s=="bigint";if(!y&&!E)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(E)l=new q(h.r,h.s);else if(y){try{l=q.fromBytes(C("sig",h),"der")}catch(v){if(!(v instanceof nt.Err))throw v}if(!l)try{l=q.fromBytes(C("sig",h),"compact")}catch{return!1}}return l||!1}function N(h,l,y,E={}){let{lowS:v,prehash:B,format:x}=Jt(E,w);if(y=C("publicKey",y),l=W(C("message",l),B),"strict"in E)throw new Error("options.strict was renamed to lowS");let _=x===void 0?lt(h):q.fromBytes(C("sig",h),x);if(_===!1)return!1;try{let I=t.fromBytes(y);if(v&&_.hasHighS())return!1;let{r:K,s:U}=_,A=X(l),V=i.inv(U),M=i.create(A*V),$=i.create(K*V),L=t.BASE.multiplyUnsafe(M).add(I.multiplyUnsafe($));return L.is0()?!1:i.create(L.x)===K}catch{return!1}}function m(h,l,y={}){let{prehash:E}=Jt(y,w);return l=W(l,E),q.fromBytes(h,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:d,getPublicKey:g,getSharedSecret:b,utils:a,lengths:u,Point:t,sign:Nt,verify:N,recoverPublicKey:m,Signature:q,hash:n})}function ln(t){let n={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp,e=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0,o=ft(n.n,{BITS:t.nBitLength,allowedLengths:e,modFromBytes:t.wrapPrivateKey}),s={Fp:r,Fn:o,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:n,curveOpts:s}}function dn(t){let{CURVE:n,curveOpts:r}=ln(t),e={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:n,curveOpts:r,hash:t.hash,ecdsaOpts:e}}function hn(t,n){let r=n.Point;return Object.assign({},n,{ProjectivePoint:r,CURVE:Object.assign({},t,Vt(r.Fn.ORDER,r.Fn.BITS))})}function He(t){let{CURVE:n,curveOpts:r,hash:e,ecdsaOpts:o}=dn(t),s=cn(n,r),i=un(s,e,o);return hn(t,i)}function Ke(t,n){let r=e=>He({...t,hash:e});return{...r(n),create:r}}var mn=J;function ut(t,n){if(qt(t),qt(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);let r=Array.from({length:n}).fill(0);for(let e=n-1;e>=0;e--)r[e]=t&255,t>>>=8;return new Uint8Array(r)}function gn(t,n){let r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t[e]^n[e];return r}function qt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Me(t){if(!ot(t)&&typeof t!="string")throw new Error("DST must be Uint8Array or string");return typeof t=="string"?st(t):t}function wn(t,n,r,e){dt(t),qt(r),n=Me(n),n.length>255&&(n=e(H(st("H2C-OVERSIZE-DST-"),n)));let{outputLen:o,blockLen:s}=e,i=Math.ceil(r/o);if(r>65535||i>255)throw new Error("expand_message_xmd: invalid lenInBytes");let f=H(n,ut(n.length,1)),c=ut(0,s),d=ut(r,2),g=new Array(i),b=e(H(c,t,d,ut(0,1),f));g[0]=e(H(b,ut(1,1),f));for(let u=1;u<=i;u++){let w=[gn(b,g[u-1]),ut(u+1,1),f];g[u]=e(H(...w))}return H(...g).slice(0,r)}function yn(t,n,r,e,o){if(dt(t),qt(r),n=Me(n),n.length>255){let s=Math.ceil(2*e/8);n=o.create({dkLen:s}).update(st("H2C-OVERSIZE-DST-")).update(n).digest()}if(r>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:r}).update(t).update(ut(r,2)).update(n).update(ut(n.length,1)).digest()}function ne(t,n,r){gt(r,{p:"bigint",m:"number",k:"number",hash:"function"});let{p:e,k:o,m:s,hash:i,expand:f,DST:c}=r;if(!ge(r.hash))throw new Error("expected valid hash");dt(t),qt(n);let d=e.toString(2).length,g=Math.ceil((d+o)/8),b=n*s*g,a;if(f==="xmd")a=wn(t,c,b,i);else if(f==="xof")a=yn(t,c,b,o,i);else if(f==="_internal_pass")a=t;else throw new Error('expand must be "xmd" or "xof"');let u=new Array(n);for(let w=0;w<n;w++){let p=new Array(s);for(let S=0;S<s;S++){let O=g*(S+w*s),T=a.subarray(O,O+g);p[S]=z(mn(T),e)}u[w]=p}return u}function ke(t,n){let r=n.map(e=>Array.from(e).reverse());return(e,o)=>{let[s,i,f,c]=r.map(b=>b.reduce((a,u)=>t.add(t.mul(a,e),u))),[d,g]=yt(t,[i,c],!0);return e=t.mul(s,d),o=t.mul(o,t.mul(f,g)),{x:e,y:o}}}var bn=st("HashToScalar-");function je(t,n,r){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function e(s){return t.fromAffine(n(s))}function o(s){let i=s.clearCofactor();return i.equals(t.ZERO)?t.ZERO:(i.assertValidity(),i)}return{defaults:r,hashToCurve(s,i){let f=Object.assign({},r,i),c=ne(s,2,f),d=e(c[0]),g=e(c[1]);return o(d.add(g))},encodeToCurve(s,i){let f=r.encodeDST?{DST:r.encodeDST}:{},c=Object.assign({},r,f,i),d=ne(s,1,c),g=e(d[0]);return o(g)},mapToCurve(s){if(!Array.isArray(s))throw new Error("expected array of bigints");for(let i of s)if(typeof i!="bigint")throw new Error("expected array of bigints");return o(e(s))},hashToScalar(s,i){let f=t.Fn.ORDER,c=Object.assign({},r,{p:f,m:1,DST:bn},i);return ne(s,1,c)[0][0]}}}var Bt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},pn={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},En=BigInt(0),Ye=BigInt(1),re=BigInt(2);function xn(t){let n=Bt.p,r=BigInt(3),e=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),f=BigInt(44),c=BigInt(88),d=t*t*t%n,g=d*d*t%n,b=P(g,r,n)*g%n,a=P(b,r,n)*g%n,u=P(a,re,n)*d%n,w=P(u,o,n)*u%n,p=P(w,s,n)*w%n,S=P(p,f,n)*p%n,O=P(S,c,n)*S%n,T=P(O,f,n)*p%n,q=P(T,r,n)*g%n,Z=P(q,i,n)*w%n,X=P(Z,e,n)*d%n,G=P(X,re,n);if(!rt.eql(rt.sqr(G),t))throw new Error("Cannot find square root");return G}var rt=ft(Bt.p,{sqrt:xn}),se=Ke({...Bt,Fp:rt,lowS:!0,endo:pn},St),ze={};function Kt(t,...n){let r=ze[t];if(r===void 0){let e=St(st(t));r=H(e,e),ze[t]=r}return St(H(r,...n))}var ie=t=>t.toBytes(!0).slice(1),vt=se.Point,ce=t=>t%re===En;function oe(t){let{Fn:n,BASE:r}=vt,e=at(n,t),o=r.multiply(e);return{scalar:ce(o.y)?e:n.neg(e),bytes:ie(o)}}function Xe(t){let n=rt;if(!n.isValidNot0(t))throw new Error("invalid x: Fail if x \u2265 p");let r=n.create(t*t),e=n.create(r*t+BigInt(7)),o=n.sqrt(e);ce(o)||(o=n.neg(o));let s=vt.fromAffine({x:t,y:o});return s.assertValidity(),s}var At=J;function $e(...t){return vt.Fn.create(At(Kt("BIP0340/challenge",...t)))}function De(t){return oe(t).bytes}function Bn(t,n,r=mt(32)){let{Fn:e}=vt,o=C("message",t),{bytes:s,scalar:i}=oe(n),f=C("auxRand",r,32),c=e.toBytes(i^At(Kt("BIP0340/aux",f))),d=Kt("BIP0340/nonce",c,s,o),{bytes:g,scalar:b}=oe(d),a=$e(g,s,o),u=new Uint8Array(64);if(u.set(g,0),u.set(e.toBytes(e.create(b+a*i)),32),!Pe(u,o,s))throw new Error("sign: Invalid signature produced");return u}function Pe(t,n,r){let{Fn:e,BASE:o}=vt,s=C("signature",t,64),i=C("message",n),f=C("publicKey",r,32);try{let c=Xe(At(f)),d=At(s.subarray(0,32));if(!It(d,Ye,Bt.p))return!1;let g=At(s.subarray(32,64));if(!It(g,Ye,Bt.n))return!1;let b=$e(e.toBytes(d),ie(c),i),a=o.multiplyUnsafe(g).add(c.multiplyUnsafe(e.neg(b))),{x:u,y:w}=a.toAffine();return!(a.is0()||!ce(w)||u!==d)}catch{return!1}}var Fn=(()=>{let r=(o=mt(48))=>Lt(o,Bt.n);se.utils.randomSecretKey;function e(o){let s=r(o);return{secretKey:s,publicKey:De(s)}}return{keygen:e,getPublicKey:De,sign:Bn,verify:Pe,Point:vt,utils:{randomSecretKey:r,randomPrivateKey:r,taggedHash:Kt,lift_x:Xe,pointToBytes:ie,numberToBytesBE:pt,bytesToNumberBE:J,mod:z},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),vn=ke(rt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),Sn=Le(rt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:rt.create(BigInt("-11"))}),Ge=je(se.Point,t=>{let{x:n,y:r}=Sn(rt.create(t[0]));return vn(n,r)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:rt.ORDER,m:1,k:128,expand:"xmd",hash:St}),tr=Ge.hashToCurve,er=Ge.encodeToCurve;export{se as a,Fn as b,Ge as c,tr as d,er as e};
