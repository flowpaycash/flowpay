import{a as He,b as Js,d as Zs}from"./chunk-HH6JVPNS.js";import{a as Ts,b as Ue,c as Ne,d as ze,e as Tt,f as Lt,g as Ys,h as rn,i as Xs,j as mr,k as sn}from"./chunk-AQSRTDKO.js";import{b as Cs}from"./chunk-4H2HG446.js";import{a as nn,b as kt,e as ft,h as we,i as js,j as hr,k as _r,o as pr,p as gr,q as yr}from"./chunk-BA3MPRCF.js";import{c as Fs}from"./chunk-PO2OHKQD.js";import{B as Vs,C as Gs,D as qs,E as Hs,i as Ms,s as Ks,w as Ae,x as De,y as Ws,z as $s}from"./chunk-W46MJTAP.js";import{a as zs}from"./chunk-CRC5266G.js";import{a as tn}from"./chunk-HUHSLM6Z.js";import{D as Ds,E as Us,G as fr,H as pe,o as en,s as Bs,u as xs,z as Ps}from"./chunk-MKYDMTOZ.js";import{s as lr,t as Ui}from"./chunk-GWB75M73.js";import{a as Pe}from"./chunk-W44JATXS.js";import{b as dr}from"./chunk-BXV67TBK.js";import{a as Ls,c as cr,l as ur,p as Qt,s as vs}from"./chunk-E62CRSR5.js";import{c as le,d as qe,e as Di,g as xe,h as ks}from"./chunk-BG6P72OF.js";var ao=qe((Dh,io)=>{"use strict";var hn=Ui().Buffer;function da(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,u=r.charAt(0),a=Math.log(i)/Math.log(256),f=Math.log(256)/Math.log(i);function h(y){if((Array.isArray(y)||y instanceof Uint8Array)&&(y=hn.from(y)),!hn.isBuffer(y))throw new TypeError("Expected Buffer");if(y.length===0)return"";for(var m=0,R=0,b=0,_=y.length;b!==_&&y[b]===0;)b++,m++;for(var E=(_-b)*f+1>>>0,O=new Uint8Array(E);b!==_;){for(var v=y[b],F=0,K=E-1;(v!==0||F<R)&&K!==-1;K--,F++)v+=256*O[K]>>>0,O[K]=v%i>>>0,v=v/i>>>0;if(v!==0)throw new Error("Non-zero carry");R=F,b++}for(var M=E-R;M!==E&&O[M]===0;)M++;for(var $=u.repeat(m);M<E;++M)$+=r.charAt(O[M]);return $}function g(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return hn.alloc(0);for(var m=0,R=0,b=0;y[m]===u;)R++,m++;for(var _=(y.length-m)*a+1>>>0,E=new Uint8Array(_);m<y.length;){var O=y.charCodeAt(m);if(O>255)return;var v=e[O];if(v===255)return;for(var F=0,K=_-1;(v!==0||F<b)&&K!==-1;K--,F++)v+=i*E[K]>>>0,E[K]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");b=F,m++}for(var M=_-b;M!==_&&E[M]===0;)M++;var $=hn.allocUnsafe(R+(_-M));$.fill(0,0,R);for(var N=R;M!==_;)$[N++]=E[M++];return $}function A(y){var m=g(y);if(m)return m;throw new Error("Non-base"+i+" character")}return{encode:h,decodeUnsafe:g,decode:A}}io.exports=da});var Ir=qe((Uh,co)=>{var la=ao(),fa="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";co.exports=la(fa)});var uo=qe(kr=>{"use strict";function Ke(r,e,t){return e<=r&&r<=t}function mn(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function ha(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var u=o&1023,a=i&1023;s.push(65536+(u<<10)+a),n+=1}else s.push(65533)}n+=1}return s}function _a(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var _n=-1;function Nr(r){this.tokens=[].slice.call(r)}Nr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():_n},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var pt=-1;function Or(r,e){if(r)throw TypeError("Decoder error");return e||65533}var pn="utf-8";function gn(r,e){if(!(this instanceof gn))return new gn(r,e);if(r=r!==void 0?String(r).toLowerCase():pn,r!==pn)throw new Error("Encoding not supported. Only utf-8 is supported");e=mn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}gn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=mn(t),this._streaming||(this._decoder=new pa({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new Nr(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==pt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===pt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),_a(o)}};function yn(r,e){if(!(this instanceof yn))return new yn(r,e);if(r=r!==void 0?String(r).toLowerCase():pn,r!==pn)throw new Error("Encoding not supported. Only utf-8 is supported");e=mn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}yn.prototype={encode:function(e,t){e=e?String(e):"",t=mn(t),this._streaming||(this._encoder=new ga(this._options)),this._streaming=!!t.stream;for(var n=[],s=new Nr(ha(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==pt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==pt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function pa(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(u,a){if(a===_n&&s!==0)return s=0,Or(e);if(a===_n)return pt;if(s===0){if(Ke(a,0,127))return a;if(Ke(a,194,223))s=1,t=a-192;else if(Ke(a,224,239))a===224&&(o=160),a===237&&(i=159),s=2,t=a-224;else if(Ke(a,240,244))a===240&&(o=144),a===244&&(i=143),s=3,t=a-240;else return Or(e);return t=t<<6*s,null}if(!Ke(a,o,i))return t=s=n=0,o=128,i=191,u.prepend(a),Or(e);if(o=128,i=191,n+=1,t+=a-128<<6*(s-n),n!==s)return null;var f=t;return t=s=n=0,f}}function ga(r){var e=r.fatal;this.handler=function(t,n){if(n===_n)return pt;if(Ke(n,0,127))return n;var s,o;Ke(n,128,2047)?(s=1,o=192):Ke(n,2048,65535)?(s=2,o=224):Ke(n,65536,1114111)&&(s=3,o=240);for(var i=[(n>>6*s)+o];s>0;){var u=n>>6*(s-1);i.push(128|u&63),s-=1}return i}}kr.TextEncoder=yn;kr.TextDecoder=gn});var po=qe(W=>{"use strict";var ya=W&&W.__createBinding||(Object.create?(function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}):(function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]})),ma=W&&W.__setModuleDefault||(Object.create?(function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}):function(r,e){r.default=e}),ve=W&&W.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var u=r.length-1;u>=0;u--)(i=r[u])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},Ra=W&&W.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&ya(e,r,t);return ma(e,r),e},lo=W&&W.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(W,"__esModule",{value:!0});W.deserializeUnchecked=W.deserialize=W.serialize=W.BinaryReader=W.BinaryWriter=W.BorshError=W.baseDecode=W.baseEncode=void 0;var Xe=lo(Ts()),fo=lo(Ir()),Sa=Ra(uo()),Ea=typeof TextDecoder!="function"?Sa.TextDecoder:TextDecoder,ba=new Ea("utf-8",{fatal:!0});function Aa(r){return typeof r=="string"&&(r=Buffer.from(r,"utf8")),fo.default.encode(Buffer.from(r))}W.baseEncode=Aa;function wa(r){return Buffer.from(fo.default.decode(r))}W.baseDecode=wa;var Tr=1024,ee=class extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}};W.BorshError=ee;var Rn=class{constructor(){this.buf=Buffer.alloc(Tr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(Tr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Xe.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Xe.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Xe.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Xe.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(Tr)]),this.length+=e.length}writeString(e){this.maybeResize();let t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(let n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}};W.BinaryWriter=Rn;function Ce(r,e,t){let n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){let i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new ee("Reached the end of buffer when deserializing")}throw o}}}var fe=class{constructor(e){this.buf=e,this.offset=0}readU8(){let e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){let e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){let e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){let e=this.readBuffer(8);return new Xe.default(e,"le")}readU128(){let e=this.readBuffer(16);return new Xe.default(e,"le")}readU256(){let e=this.readBuffer(32);return new Xe.default(e,"le")}readU512(){let e=this.readBuffer(64);return new Xe.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new ee(`Expected buffer length ${e} isn't within bounds`);let t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){let e=this.readU32(),t=this.readBuffer(e);try{return ba.decode(t)}catch(n){throw new ee(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){let t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}};ve([Ce],fe.prototype,"readU8",null);ve([Ce],fe.prototype,"readU16",null);ve([Ce],fe.prototype,"readU32",null);ve([Ce],fe.prototype,"readU64",null);ve([Ce],fe.prototype,"readU128",null);ve([Ce],fe.prototype,"readU256",null);ve([Ce],fe.prototype,"readU512",null);ve([Ce],fe.prototype,"readString",null);ve([Ce],fe.prototype,"readFixedArray",null);ve([Ce],fe.prototype,"readArray",null);W.BinaryReader=fe;function ho(r){return r.charAt(0).toUpperCase()+r.slice(1)}function ot(r,e,t,n,s){try{if(typeof n=="string")s[`write${ho(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new ee(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new ee(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)ot(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{ot(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),ot(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{ot(r,e,i,n.key,s),ot(r,e,o,n.value,s)});break}default:throw new ee(`FieldType ${n} unrecognized`)}else _o(r,t,s)}catch(o){throw o instanceof ee&&o.addToFieldPath(e),o}}function _o(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}let n=r.get(e.constructor);if(!n)throw new ee(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{ot(r,s,e[s],o,t)});else if(n.kind==="enum"){let s=e[n.field];for(let o=0;o<n.values.length;++o){let[i,u]=n.values[o];if(i===s){t.writeU8(o),ot(r,i,e[i],u,t);break}}}else throw new ee(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ia(r,e,t=Rn){let n=new t;return _o(r,e,n),n.toArray()}W.serialize=Ia;function it(r,e,t,n){try{if(typeof t=="string")return n[`read${ho(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){let s=[];for(let o=0;o<t[1];o++)s.push(it(r,null,t[0],n));return s}else return n.readArray(()=>it(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?it(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map,o=n.readU32();for(let i=0;i<o;i++){let u=it(r,e,t.key,n),a=it(r,e,t.value,n);s.set(u,a)}return s}return Lr(r,t,n)}catch(s){throw s instanceof ee&&s.addToFieldPath(e),s}}function Lr(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);let n=r.get(e);if(!n)throw new ee(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){let s={};for(let[o,i]of r.get(e).fields)s[o]=it(r,o,i,t);return new e(s)}if(n.kind==="enum"){let s=t.readU8();if(s>=n.values.length)throw new ee(`Enum index: ${s} is out of range`);let[o,i]=n.values[s],u=it(r,o,i,t);return new e({[o]:u})}throw new ee(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Oa(r,e,t,n=fe){let s=new n(t),o=Lr(r,e,s);if(s.offset<t.length)throw new ee(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}W.deserialize=Oa;function Na(r,e,t,n=fe){let s=new n(t);return Lr(r,e,s)}W.deserializeUnchecked=Na});var xr=qe(l=>{"use strict";Object.defineProperty(l,"__esModule",{value:!0});l.s16=l.s8=l.nu64be=l.u48be=l.u40be=l.u32be=l.u24be=l.u16be=l.nu64=l.u48=l.u40=l.u32=l.u24=l.u16=l.u8=l.offset=l.greedy=l.Constant=l.UTF8=l.CString=l.Blob=l.Boolean=l.BitField=l.BitStructure=l.VariantLayout=l.Union=l.UnionLayoutDiscriminator=l.UnionDiscriminator=l.Structure=l.Sequence=l.DoubleBE=l.Double=l.FloatBE=l.Float=l.NearInt64BE=l.NearInt64=l.NearUInt64BE=l.NearUInt64=l.IntBE=l.Int=l.UIntBE=l.UInt=l.OffsetLayout=l.GreedyCount=l.ExternalLayout=l.bindConstructorLayout=l.nameWithProperty=l.Layout=l.uint8ArrayToBuffer=l.checkUint8Array=void 0;l.constant=l.utf8=l.cstr=l.blob=l.unionLayoutDiscriminator=l.union=l.seq=l.bits=l.struct=l.f64be=l.f64=l.f32be=l.f32=l.ns64be=l.s48be=l.s40be=l.s32be=l.s24be=l.s16be=l.ns64=l.s48=l.s40=l.s32=l.s24=void 0;var Cr=lr();function mt(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}l.checkUint8Array=mt;function D(r){return mt(r),Cr.Buffer.from(r.buffer,r.byteOffset,r.length)}l.uint8ArrayToBuffer=D;var z=class{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){let t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}};l.Layout=z;function Br(r,e){return e.property?r+"["+e.property+"]":r}l.nameWithProperty=Br;function ka(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof z))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=(()=>new r),Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}l.bindConstructorLayout=ka;var ne=class extends z{isCount(){throw new Error("ExternalLayout is abstract")}};l.ExternalLayout=ne;var Sn=class extends ne{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){mt(e);let n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}};l.GreedyCount=Sn;var Pt=class extends ne{constructor(e,t=0,n){if(!(e instanceof z))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof ye||this.layout instanceof Re}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}};l.OffsetLayout=Pt;var ye=class extends z{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return D(e).readUIntLE(t,this.span)}encode(e,t,n=0){return D(t).writeUIntLE(e,n,this.span),this.span}};l.UInt=ye;var Re=class extends z{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return D(e).readUIntBE(t,this.span)}encode(e,t,n=0){return D(t).writeUIntBE(e,n,this.span),this.span}};l.UIntBE=Re;var We=class extends z{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return D(e).readIntLE(t,this.span)}encode(e,t,n=0){return D(t).writeIntLE(e,n,this.span),this.span}};l.Int=We;var Je=class extends z{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return D(e).readIntBE(t,this.span)}encode(e,t,n=0){return D(t).writeIntBE(e,n,this.span),this.span}};l.IntBE=Je;var vr=Math.pow(2,32);function Un(r){let e=Math.floor(r/vr),t=r-e*vr;return{hi32:e,lo32:t}}function zn(r,e){return r*vr+e}var En=class extends z{constructor(e){super(8,e)}decode(e,t=0){let n=D(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return zn(o,s)}encode(e,t,n=0){let s=Un(e),o=D(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}};l.NearUInt64=En;var bn=class extends z{constructor(e){super(8,e)}decode(e,t=0){let n=D(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return zn(s,o)}encode(e,t,n=0){let s=Un(e),o=D(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}};l.NearUInt64BE=bn;var An=class extends z{constructor(e){super(8,e)}decode(e,t=0){let n=D(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return zn(o,s)}encode(e,t,n=0){let s=Un(e),o=D(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}};l.NearInt64=An;var wn=class extends z{constructor(e){super(8,e)}decode(e,t=0){let n=D(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return zn(s,o)}encode(e,t,n=0){let s=Un(e),o=D(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}};l.NearInt64BE=wn;var In=class extends z{constructor(e){super(4,e)}decode(e,t=0){return D(e).readFloatLE(t)}encode(e,t,n=0){return D(t).writeFloatLE(e,n),4}};l.Float=In;var On=class extends z{constructor(e){super(4,e)}decode(e,t=0){return D(e).readFloatBE(t)}encode(e,t,n=0){return D(t).writeFloatBE(e,n),4}};l.FloatBE=On;var Nn=class extends z{constructor(e){super(8,e)}decode(e,t=0){return D(e).readDoubleLE(t)}encode(e,t,n=0){return D(t).writeDoubleLE(e,n),8}};l.Double=Nn;var kn=class extends z{constructor(e){super(8,e)}decode(e,t=0){return D(e).readDoubleBE(t)}encode(e,t,n=0){return D(t).writeDoubleBE(e,n),8}};l.DoubleBE=kn;var Tn=class extends z{constructor(e,t,n){if(!(e instanceof z))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof ne&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof ne)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof ne&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){let n=[],s=0,o=this.count;for(o instanceof ne&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){let s=this.elementLayout,o=e.reduce((i,u)=>i+s.encode(u,t,n+i),0);return this.count instanceof ne&&this.count.encode(e.length,t,n),o}};l.Sequence=Tn;var Ln=class extends z{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof z,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(let o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{let i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){mt(e);let n=this.makeDestinationObject();for(let s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){let s=n,o=0,i=0;for(let u of this.fields){let a=u.span;if(i=0<a?a:0,u.property!==void 0){let f=e[u.property];f!==void 0&&(i=u.encode(f,t,n),0>a&&(a=u.getSpan(t,n)))}o=n,n+=a}return o+i-s}fromArray(e){let t=this.makeDestinationObject();for(let n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(let n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}};l.Structure=Ln;var Dt=class{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}};l.UnionDiscriminator=Dt;var yt=class extends Dt{constructor(e,t){if(!(e instanceof ne&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}};l.UnionLayoutDiscriminator=yt;var Ut=class extends z{constructor(e,t,n){let s;if(e instanceof ye||e instanceof Re)s=new yt(new Pt(e));else if(e instanceof ne&&e.isCount())s=new yt(e);else if(e instanceof Dt)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof z))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof ye||e instanceof Re)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof ye||e instanceof Re,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(u){return i(u)},this.configGetSourceVariant=function(u){i=u.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;let n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;let t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(let t in this.registry){let n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n,s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){let u=this.defaultLayout,a=0;this.usesPrefixDiscriminator&&(a=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[u.property]=u.decode(e,t+a)}else n=i.decode(e,t);return n}encode(e,t,n=0){let s=this.getSourceVariant(e);if(s===void 0){let o=this.discriminator,i=this.defaultLayout,u=0;return this.usesPrefixDiscriminator&&(u=o.layout.span),o.encode(e[o.property],t,n),u+i.encode(e[i.property],t,n+u)}return s.encode(e,t,n)}addVariant(e,t,n){let s=new vn(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}};l.Union=Ut;var vn=class extends z{constructor(e,t,n,s){if(!(e instanceof Ut))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof z))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){let n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}};l.VariantLayout=vn;function gt(r){return 0>r&&(r+=4294967296),r}var zt=class extends z{constructor(e,t,n){if(!(e instanceof ye||e instanceof Re))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=gt(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){let n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(let o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){let s=this.word.decode(t,n);this._packedSetValue(s);for(let o of this.fields)if(o.property!==void 0){let i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){let n=new Mt(this,e,t);return this.fields.push(n),n}addBoolean(e){let t=new Cn(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}};l.BitStructure=zt;var Mt=class{constructor(e,t,n){if(!(e instanceof zt))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");let s=8*e.span,o=e.fields.reduce((i,u)=>i+u.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=gt(this.valueMask<<this.start),this.property=n}decode(e,t){let n=this.container._packedGetValue();return gt(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==gt(e&this.valueMask))throw new TypeError(Br("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);let t=this.container._packedGetValue(),n=gt(e<<this.start);this.container._packedSetValue(gt(t&~this.wordMask)|n)}};l.BitField=Mt;var Cn=class extends Mt{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};l.Boolean=Cn;var Bn=class extends z{constructor(e,t){if(!(e instanceof ne&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof ne||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),D(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof ne&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(Br("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");let o=D(e);return D(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof ne&&this.length.encode(s,t,n),s}};l.Blob=Bn;var xn=class extends z{constructor(e){super(-1,e)}getSpan(e,t=0){mt(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){let n=this.getSpan(e,t);return D(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let s=Cr.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");let i=D(t);return s.copy(i,n),i[n+o]=0,o+1}};l.CString=xn;var Pn=class extends z{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return mt(e),e.length-t}decode(e,t=0){let n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return D(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let s=Cr.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(D(t),n),o}};l.UTF8=Pn;var Dn=class extends z{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}};l.Constant=Dn;l.greedy=((r,e)=>new Sn(r,e));l.offset=((r,e,t)=>new Pt(r,e,t));l.u8=(r=>new ye(1,r));l.u16=(r=>new ye(2,r));l.u24=(r=>new ye(3,r));l.u32=(r=>new ye(4,r));l.u40=(r=>new ye(5,r));l.u48=(r=>new ye(6,r));l.nu64=(r=>new En(r));l.u16be=(r=>new Re(2,r));l.u24be=(r=>new Re(3,r));l.u32be=(r=>new Re(4,r));l.u40be=(r=>new Re(5,r));l.u48be=(r=>new Re(6,r));l.nu64be=(r=>new bn(r));l.s8=(r=>new We(1,r));l.s16=(r=>new We(2,r));l.s24=(r=>new We(3,r));l.s32=(r=>new We(4,r));l.s40=(r=>new We(5,r));l.s48=(r=>new We(6,r));l.ns64=(r=>new An(r));l.s16be=(r=>new Je(2,r));l.s24be=(r=>new Je(3,r));l.s32be=(r=>new Je(4,r));l.s40be=(r=>new Je(5,r));l.s48be=(r=>new Je(6,r));l.ns64be=(r=>new wn(r));l.f32=(r=>new In(r));l.f32be=(r=>new On(r));l.f64=(r=>new Nn(r));l.f64be=(r=>new kn(r));l.struct=((r,e,t)=>new Ln(r,e,t));l.bits=((r,e,t)=>new zt(r,e,t));l.seq=((r,e,t)=>new Tn(r,e,t));l.union=((r,e,t)=>new Ut(r,e,t));l.unionLayoutDiscriminator=((r,e)=>new yt(r,e));l.blob=((r,e)=>new Bn(r,e));l.cstr=(r=>new xn(r));l.utf8=((r,e)=>new Pn(r,e));l.constant=((r,e)=>new Dn(r,e))});function Wt(){if(!Wn&&(Wn=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!Wn))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Wn(Wl)}var Wn,Wl,Gr=le(()=>{Wl=new Uint8Array(16)});var xo,Po=le(()=>{xo=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i});function $l(r){return typeof r=="string"&&xo.test(r)}var Qe,$t=le(()=>{Po();Qe=$l});function Vl(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(te[r[e+0]]+te[r[e+1]]+te[r[e+2]]+te[r[e+3]]+"-"+te[r[e+4]]+te[r[e+5]]+"-"+te[r[e+6]]+te[r[e+7]]+"-"+te[r[e+8]]+te[r[e+9]]+"-"+te[r[e+10]]+te[r[e+11]]+te[r[e+12]]+te[r[e+13]]+te[r[e+14]]+te[r[e+15]]).toLowerCase();if(!Qe(t))throw TypeError("Stringified UUID is invalid");return t}var te,$n,et,Vt=le(()=>{$t();te=[];for($n=0;$n<256;++$n)te.push(($n+256).toString(16).substr(1));et=Vl});function Gl(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||Do,i=r.clockseq!==void 0?r.clockseq:qr;if(o==null||i==null){var u=r.random||(r.rng||Wt)();o==null&&(o=Do=[u[0]|1,u[1],u[2],u[3],u[4],u[5]]),i==null&&(i=qr=(u[6]<<8|u[7])&16383)}var a=r.msecs!==void 0?r.msecs:Date.now(),f=r.nsecs!==void 0?r.nsecs:jr+1,h=a-Hr+(f-jr)/1e4;if(h<0&&r.clockseq===void 0&&(i=i+1&16383),(h<0||a>Hr)&&r.nsecs===void 0&&(f=0),f>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Hr=a,jr=f,qr=i,a+=122192928e5;var g=((a&268435455)*1e4+f)%4294967296;s[n++]=g>>>24&255,s[n++]=g>>>16&255,s[n++]=g>>>8&255,s[n++]=g&255;var A=a/4294967296*1e4&268435455;s[n++]=A>>>8&255,s[n++]=A&255,s[n++]=A>>>24&15|16,s[n++]=A>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var y=0;y<6;++y)s[n+y]=o[y];return e||et(s)}var Do,qr,Hr,jr,Uo,zo=le(()=>{Gr();Vt();Hr=0,jr=0;Uo=Gl});function ql(r){if(!Qe(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}var Vn,Yr=le(()=>{$t();Vn=ql});function Hl(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}function Gn(r,e,t){function n(s,o,i,u){if(typeof s=="string"&&(s=Hl(s)),typeof o=="string"&&(o=Vn(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var a=new Uint8Array(16+s.length);if(a.set(o),a.set(s,o.length),a=t(a),a[6]=a[6]&15|e,a[8]=a[8]&63|128,i){u=u||0;for(var f=0;f<16;++f)i[u+f]=a[f];return i}return et(a)}try{n.name=r}catch{}return n.DNS=jl,n.URL=Yl,n}var jl,Yl,Xr=le(()=>{Vt();Yr();jl="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Yl="6ba7b811-9dad-11d1-80b4-00c04fd430c8"});function Xl(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return Jl(Zl(Ql(r),r.length*8))}function Jl(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function Mo(r){return(r+64>>>9<<4)+14+1}function Zl(r,e){r[e>>5]|=128<<e%32,r[Mo(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var u=t,a=n,f=s,h=o;t=se(t,n,s,o,r[i],7,-680876936),o=se(o,t,n,s,r[i+1],12,-389564586),s=se(s,o,t,n,r[i+2],17,606105819),n=se(n,s,o,t,r[i+3],22,-1044525330),t=se(t,n,s,o,r[i+4],7,-176418897),o=se(o,t,n,s,r[i+5],12,1200080426),s=se(s,o,t,n,r[i+6],17,-1473231341),n=se(n,s,o,t,r[i+7],22,-45705983),t=se(t,n,s,o,r[i+8],7,1770035416),o=se(o,t,n,s,r[i+9],12,-1958414417),s=se(s,o,t,n,r[i+10],17,-42063),n=se(n,s,o,t,r[i+11],22,-1990404162),t=se(t,n,s,o,r[i+12],7,1804603682),o=se(o,t,n,s,r[i+13],12,-40341101),s=se(s,o,t,n,r[i+14],17,-1502002290),n=se(n,s,o,t,r[i+15],22,1236535329),t=oe(t,n,s,o,r[i+1],5,-165796510),o=oe(o,t,n,s,r[i+6],9,-1069501632),s=oe(s,o,t,n,r[i+11],14,643717713),n=oe(n,s,o,t,r[i],20,-373897302),t=oe(t,n,s,o,r[i+5],5,-701558691),o=oe(o,t,n,s,r[i+10],9,38016083),s=oe(s,o,t,n,r[i+15],14,-660478335),n=oe(n,s,o,t,r[i+4],20,-405537848),t=oe(t,n,s,o,r[i+9],5,568446438),o=oe(o,t,n,s,r[i+14],9,-1019803690),s=oe(s,o,t,n,r[i+3],14,-187363961),n=oe(n,s,o,t,r[i+8],20,1163531501),t=oe(t,n,s,o,r[i+13],5,-1444681467),o=oe(o,t,n,s,r[i+2],9,-51403784),s=oe(s,o,t,n,r[i+7],14,1735328473),n=oe(n,s,o,t,r[i+12],20,-1926607734),t=ie(t,n,s,o,r[i+5],4,-378558),o=ie(o,t,n,s,r[i+8],11,-2022574463),s=ie(s,o,t,n,r[i+11],16,1839030562),n=ie(n,s,o,t,r[i+14],23,-35309556),t=ie(t,n,s,o,r[i+1],4,-1530992060),o=ie(o,t,n,s,r[i+4],11,1272893353),s=ie(s,o,t,n,r[i+7],16,-155497632),n=ie(n,s,o,t,r[i+10],23,-1094730640),t=ie(t,n,s,o,r[i+13],4,681279174),o=ie(o,t,n,s,r[i],11,-358537222),s=ie(s,o,t,n,r[i+3],16,-722521979),n=ie(n,s,o,t,r[i+6],23,76029189),t=ie(t,n,s,o,r[i+9],4,-640364487),o=ie(o,t,n,s,r[i+12],11,-421815835),s=ie(s,o,t,n,r[i+15],16,530742520),n=ie(n,s,o,t,r[i+2],23,-995338651),t=ae(t,n,s,o,r[i],6,-198630844),o=ae(o,t,n,s,r[i+7],10,1126891415),s=ae(s,o,t,n,r[i+14],15,-1416354905),n=ae(n,s,o,t,r[i+5],21,-57434055),t=ae(t,n,s,o,r[i+12],6,1700485571),o=ae(o,t,n,s,r[i+3],10,-1894986606),s=ae(s,o,t,n,r[i+10],15,-1051523),n=ae(n,s,o,t,r[i+1],21,-2054922799),t=ae(t,n,s,o,r[i+8],6,1873313359),o=ae(o,t,n,s,r[i+15],10,-30611744),s=ae(s,o,t,n,r[i+6],15,-1560198380),n=ae(n,s,o,t,r[i+13],21,1309151649),t=ae(t,n,s,o,r[i+4],6,-145523070),o=ae(o,t,n,s,r[i+11],10,-1120210379),s=ae(s,o,t,n,r[i+2],15,718787259),n=ae(n,s,o,t,r[i+9],21,-343485551),t=tt(t,u),n=tt(n,a),s=tt(s,f),o=tt(o,h)}return[t,n,s,o]}function Ql(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(Mo(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function tt(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function ef(r,e){return r<<e|r>>>32-e}function qn(r,e,t,n,s,o){return tt(ef(tt(tt(e,r),tt(n,o)),s),t)}function se(r,e,t,n,s,o,i){return qn(e&t|~e&n,r,e,s,o,i)}function oe(r,e,t,n,s,o,i){return qn(e&n|t&~n,r,e,s,o,i)}function ie(r,e,t,n,s,o,i){return qn(e^t^n,r,e,s,o,i)}function ae(r,e,t,n,s,o,i){return qn(t^(e|~n),r,e,s,o,i)}var Fo,Ko=le(()=>{Fo=Xl});var tf,Wo,$o=le(()=>{Xr();Ko();tf=Gn("v3",48,Fo),Wo=tf});function nf(r,e,t){r=r||{};var n=r.random||(r.rng||Wt)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return et(n)}var Vo,Go=le(()=>{Gr();Vt();Vo=nf});function rf(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function Jr(r,e){return r<<e|r>>>32-e}function sf(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),u=new Array(i),a=0;a<i;++a){for(var f=new Uint32Array(16),h=0;h<16;++h)f[h]=r[a*64+h*4]<<24|r[a*64+h*4+1]<<16|r[a*64+h*4+2]<<8|r[a*64+h*4+3];u[a]=f}u[i-1][14]=(r.length-1)*8/Math.pow(2,32),u[i-1][14]=Math.floor(u[i-1][14]),u[i-1][15]=(r.length-1)*8&4294967295;for(var g=0;g<i;++g){for(var A=new Uint32Array(80),y=0;y<16;++y)A[y]=u[g][y];for(var m=16;m<80;++m)A[m]=Jr(A[m-3]^A[m-8]^A[m-14]^A[m-16],1);for(var R=t[0],b=t[1],_=t[2],E=t[3],O=t[4],v=0;v<80;++v){var F=Math.floor(v/20),K=Jr(R,5)+rf(F,b,_,E)+O+e[F]+A[v]>>>0;O=E,E=_,_=Jr(b,30)>>>0,b=R,R=K}t[0]=t[0]+R>>>0,t[1]=t[1]+b>>>0,t[2]=t[2]+_>>>0,t[3]=t[3]+E>>>0,t[4]=t[4]+O>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var qo,Ho=le(()=>{qo=sf});var of,jo,Yo=le(()=>{Xr();Ho();of=Gn("v5",80,qo),jo=of});var Xo,Jo=le(()=>{Xo="00000000-0000-0000-0000-000000000000"});function af(r){if(!Qe(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}var Zo,Qo=le(()=>{$t();Zo=af});var Zr={};Di(Zr,{NIL:()=>Xo,parse:()=>Vn,stringify:()=>et,v1:()=>Uo,v3:()=>Wo,v4:()=>Vo,v5:()=>jo,validate:()=>Qe,version:()=>Zo});var Qr=le(()=>{zo();$o();Go();Yo();Jo();Qo();$t();Vt();Yr()});var ti=qe((B_,ei)=>{"use strict";var cf=(Qr(),ks(Zr)).v4,uf=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};let s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");let o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){let i=typeof n.generator=="function"?n.generator:function(){return cf()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};ei.exports=uf});var ri=qe((x_,ni)=>{"use strict";var df=(Qr(),ks(Zr)).v4,lf=ti(),Gt=function(r,e){if(!(this instanceof Gt))return new Gt(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return df()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};ni.exports=Gt;Gt.prototype.request=function(r,e,t,n){let s=this,o=null,i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);let f=typeof n=="function";try{o=lf(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(h){if(f)return n(h);throw h}if(!f)return o}let a;try{a=JSON.stringify(o,this.options.replacer)}catch(f){return n(f)}return this.callServer(a,function(f,h){s._parseResponse(f,h,n)}),o};Gt.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){let s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)}});var oi=qe((P_,es)=>{"use strict";var ff=Object.prototype.hasOwnProperty,he="~";function qt(){}Object.create&&(qt.prototype=Object.create(null),new qt().__proto__||(he=!1));function hf(r,e,t){this.fn=r,this.context=e,this.once=t||!1}function si(r,e,t,n,s){if(typeof t!="function")throw new TypeError("The listener must be a function");var o=new hf(t,n||r,s),i=he?he+e:e;return r._events[i]?r._events[i].fn?r._events[i]=[r._events[i],o]:r._events[i].push(o):(r._events[i]=o,r._eventsCount++),r}function Hn(r,e){--r._eventsCount===0?r._events=new qt:delete r._events[e]}function ce(){this._events=new qt,this._eventsCount=0}ce.prototype.eventNames=function(){var e=[],t,n;if(this._eventsCount===0)return e;for(n in t=this._events)ff.call(t,n)&&e.push(he?n.slice(1):n);return Object.getOwnPropertySymbols?e.concat(Object.getOwnPropertySymbols(t)):e};ce.prototype.listeners=function(e){var t=he?he+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,o=n.length,i=new Array(o);s<o;s++)i[s]=n[s].fn;return i};ce.prototype.listenerCount=function(e){var t=he?he+e:e,n=this._events[t];return n?n.fn?1:n.length:0};ce.prototype.emit=function(e,t,n,s,o,i){var u=he?he+e:e;if(!this._events[u])return!1;var a=this._events[u],f=arguments.length,h,g;if(a.fn){switch(a.once&&this.removeListener(e,a.fn,void 0,!0),f){case 1:return a.fn.call(a.context),!0;case 2:return a.fn.call(a.context,t),!0;case 3:return a.fn.call(a.context,t,n),!0;case 4:return a.fn.call(a.context,t,n,s),!0;case 5:return a.fn.call(a.context,t,n,s,o),!0;case 6:return a.fn.call(a.context,t,n,s,o,i),!0}for(g=1,h=new Array(f-1);g<f;g++)h[g-1]=arguments[g];a.fn.apply(a.context,h)}else{var A=a.length,y;for(g=0;g<A;g++)switch(a[g].once&&this.removeListener(e,a[g].fn,void 0,!0),f){case 1:a[g].fn.call(a[g].context);break;case 2:a[g].fn.call(a[g].context,t);break;case 3:a[g].fn.call(a[g].context,t,n);break;case 4:a[g].fn.call(a[g].context,t,n,s);break;default:if(!h)for(y=1,h=new Array(f-1);y<f;y++)h[y-1]=arguments[y];a[g].fn.apply(a[g].context,h)}}return!0};ce.prototype.on=function(e,t,n){return si(this,e,t,n,!1)};ce.prototype.once=function(e,t,n){return si(this,e,t,n,!0)};ce.prototype.removeListener=function(e,t,n,s){var o=he?he+e:e;if(!this._events[o])return this;if(!t)return Hn(this,o),this;var i=this._events[o];if(i.fn)i.fn===t&&(!s||i.once)&&(!n||i.context===n)&&Hn(this,o);else{for(var u=0,a=[],f=i.length;u<f;u++)(i[u].fn!==t||s&&!i[u].once||n&&i[u].context!==n)&&a.push(i[u]);a.length?this._events[o]=a.length===1?a[0]:a:Hn(this,o)}return this};ce.prototype.removeAllListeners=function(e){var t;return e?(t=he?he+e:e,this._events[t]&&Hn(this,t)):(this._events=new qt,this._eventsCount=0),this};ce.prototype.off=ce.prototype.removeListener;ce.prototype.addListener=ce.prototype.on;ce.prefixed=he;ce.EventEmitter=ce;typeof es<"u"&&(es.exports=ce)});var on="solana:signAndSendTransaction";var an="solana:signMessage";var vt="solana:signTransaction";var zi=function(r,e,t,n){if(t==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?r!==e||!n:!e.has(r))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(r):n?n.value:e.get(r)},Mi=function(r,e,t,n,s){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?r!==e||!s:!e.has(r))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?s.call(r,t):s?s.value=t:e.set(r,t),t},cn,Ct,un=new Set;function Fi(r){Bt=void 0,un.add(r)}function Ki(r){Bt=void 0,un.delete(r)}var ht={};function Wi(){if(Ct||(Ct=Object.freeze({register:Qs,get:$i,on:Vi}),typeof window>"u"))return Ct;let r=Object.freeze({register:Qs});try{window.addEventListener("wallet-standard:register-wallet",({detail:e})=>e(r))}catch{}try{window.dispatchEvent(new Rr(r))}catch{}return Ct}function Qs(...r){return r=r.filter(e=>!un.has(e)),r.length?(r.forEach(e=>Fi(e)),ht.register?.forEach(e=>eo(()=>e(...r))),function(){r.forEach(t=>Ki(t)),ht.unregister?.forEach(t=>eo(()=>t(...r)))}):()=>{}}var Bt;function $i(){return Bt||(Bt=[...un]),Bt}function Vi(r,e){return ht[r]?.push(e)||(ht[r]=[e]),function(){ht[r]=ht[r]?.filter(n=>e!==n)}}function eo(r){try{r()}catch{}}var Rr=class extends Event{get detail(){return zi(this,cn,"f")}get type(){return"wallet-standard:app-ready"}constructor(e){super("wallet-standard:app-ready",{bubbles:!1,cancelable:!1,composed:!1}),cn.set(this,void 0),Mi(this,cn,e,"f")}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}};cn=new WeakMap;var dn="standard:connect";var to="standard:disconnect";var ln=class extends $s{async init(e){}async getIdentityToken(){if(!this.provider||this.status!==Ae.CONNECTED)throw pe.notConnectedError();if(!this.coreOptions)throw fr.invalidParams("Please initialize Web3Auth with a valid options");let e=await this.provider.request({method:tn.GET_ACCOUNTS});if(e&&e.length>0){let t=Gs(e[0],this.name);if(t&&!Vs(t))return{idToken:t};let n=await this.provider.request({method:"solana_chainId"}),s=this.coreOptions.chains.find(h=>h.chainId===n);if(!s)throw fr.invalidParams("chainConfig is required before authentication");let{chainNamespace:o}=s,i={domain:window.location.origin,uri:window.location.href,address:e[0],chainId:parseInt(n,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:new Date().toISOString()},u=await Ds(i,o),a=await this.provider.request({method:tn.SIGN_MESSAGE,params:{data:u,display:"utf8"}}),f=await Us(o,a,u,this.name,this.coreOptions.sessionTime,this.coreOptions.clientId,this.coreOptions.web3AuthNetwork);return qs(e[0],this.name,f),{idToken:f}}throw pe.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnectSession(){super.checkDisconnectionRequirements();let e=await this.provider.request({method:tn.GET_ACCOUNTS});e&&e.length>0&&Hs(e[0],this.name)}async disconnect(){this.rehydrated=!1,this.emit(De.DISCONNECTED)}};var L=xe(lr());var je=BigInt(0),Q=BigInt(1),Sr=BigInt(2),Gi=BigInt(8);function qi(r,e,t,n){let s=r.sqr(t),o=r.sqr(n),i=r.add(r.mul(e.a,s),o),u=r.add(r.ONE,r.mul(e.d,r.mul(s,o)));return r.eql(i,u)}function Hi(r,e={}){let t=Xs("edwards",r,e,e.FpFnLE),{Fp:n,Fn:s}=t,o=t.CURVE,{h:i}=o;pr(e,{},{uvRatio:"function"});let u=Sr<<BigInt(s.BYTES*8)-Q,a=b=>n.create(b),f=e.uvRatio||((b,_)=>{try{return{isValid:!0,value:n.sqrt(n.div(b,_))}}catch{return{isValid:!1,value:je}}});if(!qi(n,o,o.Gx,o.Gy))throw new Error("bad curve params: generator point");function h(b,_,E=!1){let O=E?Q:je;return _r("coordinate "+b,_,O,u),_}function g(b){if(!(b instanceof m))throw new Error("ExtendedPoint expected")}let A=yr((b,_)=>{let{X:E,Y:O,Z:v}=b,F=b.is0();_==null&&(_=F?Gi:n.inv(v));let K=a(E*_),M=a(O*_),$=n.mul(v,_);if(F)return{x:je,y:Q};if($!==Q)throw new Error("invZ was invalid");return{x:K,y:M}}),y=yr(b=>{let{a:_,d:E}=o;if(b.is0())throw new Error("bad point: ZERO");let{X:O,Y:v,Z:F,T:K}=b,M=a(O*O),$=a(v*v),N=a(F*F),T=a(N*N),x=a(M*_),X=a(N*a(x+$)),Z=a(T+a(E*a(M*$)));if(X!==Z)throw new Error("bad point: equation left != right (1)");let H=a(O*v),de=a(F*K);if(H!==de)throw new Error("bad point: equation left != right (2)");return!0});class m{constructor(_,E,O,v){this.X=h("x",_),this.Y=h("y",E),this.Z=h("z",O,!0),this.T=h("t",v),Object.freeze(this)}static CURVE(){return o}static fromAffine(_){if(_ instanceof m)throw new Error("extended point not allowed");let{x:E,y:O}=_||{};return h("x",E),h("y",O),new m(E,O,Q,a(E*O))}static fromBytes(_,E=!1){let O=n.BYTES,{a:v,d:F}=o;_=hr(kt(_,O,"point")),nn(E,"zip215");let K=hr(_),M=_[O-1];K[O-1]=M&-129;let $=ft(K),N=E?u:n.ORDER;_r("point.y",$,je,N);let T=a($*$),x=a(T-Q),X=a(F*T-v),{isValid:Z,value:H}=f(x,X);if(!Z)throw new Error("bad point: invalid y coordinate");let de=(H&Q)===Q,me=(M&128)!==0;if(!E&&H===je&&me)throw new Error("bad point: x=0 and x_0=1");return me!==de&&(H=a(-H)),m.fromAffine({x:H,y:$})}static fromHex(_,E=!1){return m.fromBytes(we("point",_),E)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(_=8,E=!0){return R.createCache(this,_),E||this.multiply(Sr),this}assertValidity(){y(this)}equals(_){g(_);let{X:E,Y:O,Z:v}=this,{X:F,Y:K,Z:M}=_,$=a(E*M),N=a(F*v),T=a(O*M),x=a(K*v);return $===N&&T===x}is0(){return this.equals(m.ZERO)}negate(){return new m(a(-this.X),this.Y,this.Z,a(-this.T))}double(){let{a:_}=o,{X:E,Y:O,Z:v}=this,F=a(E*E),K=a(O*O),M=a(Sr*a(v*v)),$=a(_*F),N=E+O,T=a(a(N*N)-F-K),x=$+K,X=x-M,Z=$-K,H=a(T*X),de=a(x*Z),me=a(T*Z),Ge=a(X*x);return new m(H,de,Ge,me)}add(_){g(_);let{a:E,d:O}=o,{X:v,Y:F,Z:K,T:M}=this,{X:$,Y:N,Z:T,T:x}=_,X=a(v*$),Z=a(F*N),H=a(M*O*x),de=a(K*T),me=a((v+F)*($+N)-X-Z),Ge=de-H,st=de+H,Be=a(Z-E*X),Nt=a(me*Ge),Zt=a(st*Be),ar=a(me*Be),Ns=a(Ge*st);return new m(Nt,Zt,Ns,ar)}subtract(_){return this.add(_.negate())}multiply(_){if(!s.isValidNot0(_))throw new Error("invalid scalar: expected 1 <= sc < curve.n");let{p:E,f:O}=R.cached(this,_,v=>Lt(m,v));return Lt(m,[E,O])[0]}multiplyUnsafe(_,E=m.ZERO){if(!s.isValid(_))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return _===je?m.ZERO:this.is0()||_===Q?this:R.unsafe(this,_,O=>Lt(m,O),E)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return R.unsafe(this,o.n).is0()}toAffine(_){return A(this,_)}clearCofactor(){return i===Q?this:this.multiplyUnsafe(i)}toBytes(){let{x:_,y:E}=this.toAffine(),O=n.toBytes(E);return O[O.length-1]|=_&Q?128:0,O}toHex(){return ur(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(_){return Lt(m,_)}static msm(_,E){return rn(m,s,_,E)}_setWindowSize(_){this.precompute(_)}toRawBytes(){return this.toBytes()}}m.BASE=new m(o.Gx,o.Gy,Q,a(o.Gx*o.Gy)),m.ZERO=new m(je,Q,Q,je),m.Fp=n,m.Fn=s;let R=new Ys(m,s.BITS);return m.BASE.precompute(8),m}var fn=class{constructor(e){this.ep=e}static fromBytes(e){gr()}static fromHex(e){gr()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(e){return this.ep.toAffine(e)}toHex(){return ur(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(e){return this.assertSame(e),this.init(this.ep.add(e.ep))}subtract(e){return this.assertSame(e),this.init(this.ep.subtract(e.ep))}multiply(e){return this.init(this.ep.multiply(e))}multiplyUnsafe(e){return this.init(this.ep.multiplyUnsafe(e))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(e,t){return this.init(this.ep.precompute(e,t))}toRawBytes(){return this.toBytes()}};function ji(r,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');pr(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});let{prehash:n}=t,{BASE:s,Fp:o,Fn:i}=r,u=t.randomBytes||vs,a=t.adjustScalarBytes||(N=>N),f=t.domain||((N,T,x)=>{if(nn(x,"phflag"),T.length||x)throw new Error("Contexts/pre-hash are not supported");return N});function h(N){return i.create(ft(N))}function g(N){let T=O.secretKey;N=we("private key",N,T);let x=we("hashed private key",e(N),2*T),X=a(x.slice(0,T)),Z=x.slice(T,2*T),H=h(X);return{head:X,prefix:Z,scalar:H}}function A(N){let{head:T,prefix:x,scalar:X}=g(N),Z=s.multiply(X),H=Z.toBytes();return{head:T,prefix:x,scalar:X,point:Z,pointBytes:H}}function y(N){return A(N).pointBytes}function m(N=Uint8Array.of(),...T){let x=Qt(...T);return h(e(f(x,we("context",N),!!n)))}function R(N,T,x={}){N=we("message",N),n&&(N=n(N));let{prefix:X,scalar:Z,pointBytes:H}=A(T),de=m(x.context,X,N),me=s.multiply(de).toBytes(),Ge=m(x.context,me,H,N),st=i.create(de+Ge*Z);if(!i.isValid(st))throw new Error("sign failed: invalid s");let Be=Qt(me,i.toBytes(st));return kt(Be,O.signature,"result")}let b={zip215:!0};function _(N,T,x,X=b){let{context:Z,zip215:H}=X,de=O.signature;N=we("signature",N,de),T=we("message",T),x=we("publicKey",x,O.publicKey),H!==void 0&&nn(H,"zip215"),n&&(T=n(T));let me=de/2,Ge=N.subarray(0,me),st=ft(N.subarray(me,de)),Be,Nt,Zt;try{Be=r.fromBytes(x,H),Nt=r.fromBytes(Ge,H),Zt=s.multiplyUnsafe(st)}catch{return!1}if(!H&&Be.isSmallOrder())return!1;let ar=m(Z,Nt.toBytes(),Be.toBytes(),T);return Nt.add(Be.multiplyUnsafe(ar)).subtract(Zt).clearCofactor().is0()}let E=o.BYTES,O={secretKey:E,publicKey:E,signature:2*E,seed:E};function v(N=u(O.seed)){return kt(N,O.seed,"seed")}function F(N){let T=$.randomSecretKey(N);return{secretKey:T,publicKey:y(T)}}function K(N){return Ls(N)&&N.length===i.BYTES}function M(N,T){try{return!!r.fromBytes(N,T)}catch{return!1}}let $={getExtendedPublicKey:A,randomSecretKey:v,isValidSecretKey:K,isValidPublicKey:M,toMontgomery(N){let{y:T}=r.fromBytes(N),x=O.publicKey,X=x===32;if(!X&&x!==57)throw new Error("only defined for 25519 and 448");let Z=X?o.div(Q+T,Q-T):o.div(T-Q,T+Q);return o.toBytes(Z)},toMontgomerySecret(N){let T=O.secretKey;kt(N,T);let x=e(N.subarray(0,T));return a(x).subarray(0,T)},randomPrivateKey:v,precompute(N=8,T=r.BASE){return T.precompute(N,!1)}};return Object.freeze({keygen:F,getPublicKey:y,sign:R,verify:_,utils:$,Point:r,lengths:O})}function Yi(r){let e={a:r.a,d:r.d,p:r.Fp.ORDER,n:r.n,h:r.h,Gx:r.Gx,Gy:r.Gy},t=r.Fp,n=Tt(e.n,r.nBitLength,!0),s={Fp:t,Fn:n,uvRatio:r.uvRatio},o={randomBytes:r.randomBytes,adjustScalarBytes:r.adjustScalarBytes,domain:r.domain,prehash:r.prehash,mapToCurve:r.mapToCurve};return{CURVE:e,curveOpts:s,hash:r.hash,eddsaOpts:o}}function Xi(r,e){let t=e.Point;return Object.assign({},e,{ExtendedPoint:t,CURVE:r,nBitLength:t.Fn.BITS,nByteLength:t.Fn.BYTES})}function no(r){let{CURVE:e,curveOpts:t,hash:n,eddsaOpts:s}=Yi(r),o=Hi(e,t),i=ji(o,n,s);return Xi(r,i)}var Ji=BigInt(0),Me=BigInt(1),ro=BigInt(2),xh=BigInt(3),Zi=BigInt(5),Qi=BigInt(8),_t=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),xt={p:_t,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Qi,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function ea(r){let e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),o=_t,u=r*r%o*r%o,a=Ne(u,ro,o)*u%o,f=Ne(a,Me,o)*r%o,h=Ne(f,Zi,o)*f%o,g=Ne(h,e,o)*h%o,A=Ne(g,t,o)*g%o,y=Ne(A,n,o)*A%o,m=Ne(y,s,o)*y%o,R=Ne(m,s,o)*y%o,b=Ne(R,e,o)*h%o;return{pow_p_5_8:Ne(b,ro,o)*r%o,b2:u}}function ta(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}var Er=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function wr(r,e){let t=_t,n=Ue(e*e*e,t),s=Ue(n*n*e,t),o=ea(r*s).pow_p_5_8,i=Ue(r*n*o,t),u=Ue(e*i*i,t),a=i,f=Ue(i*Er,t),h=u===r,g=u===Ue(-r,t),A=u===Ue(-r*Er,t);return h&&(i=a),(g||A)&&(i=f),ze(i,t)&&(i=Ue(-i,t)),{isValid:h||g,value:i}}var Ye=Tt(xt.p,{isLE:!0}),na=Tt(xt.n,{isLE:!0}),ra={...xt,Fp:Ye,hash:Cs,adjustScalarBytes:ta,uvRatio:wr},ge=no(ra);var br=Er,sa=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),oa=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ia=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),aa=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),so=r=>wr(Me,r),ca=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),Ar=r=>ge.Point.Fp.create(ft(r)&ca);function oo(r){let{d:e}=xt,t=_t,n=_=>Ye.create(_),s=n(br*r*r),o=n((s+Me)*ia),i=BigInt(-1),u=n((i-e*s)*n(s+e)),{isValid:a,value:f}=wr(o,u),h=n(f*r);ze(h,t)||(h=n(-h)),a||(f=h),a||(i=s);let g=n(i*(s-Me)*aa-u),A=f*f,y=n((f+f)*u),m=n(g*sa),R=n(Me-A),b=n(Me+A);return new ge.Point(n(y*b),n(R*m),n(m*b),n(y*R))}function ua(r){cr(r,64);let e=Ar(r.subarray(0,32)),t=oo(e),n=Ar(r.subarray(32,64)),s=oo(n);return new Fe(t.add(s))}var Fe=class r extends fn{constructor(e){super(e)}static fromAffine(e){return new r(ge.Point.fromAffine(e))}assertSame(e){if(!(e instanceof r))throw new Error("RistrettoPoint expected")}init(e){return new r(e)}static hashToCurve(e){return ua(we("ristrettoHash",e,64))}static fromBytes(e){cr(e,32);let{a:t,d:n}=xt,s=_t,o=v=>Ye.create(v),i=Ar(e);if(!js(Ye.toBytes(i),e)||ze(i,s))throw new Error("invalid ristretto255 encoding 1");let u=o(i*i),a=o(Me+t*u),f=o(Me-t*u),h=o(a*a),g=o(f*f),A=o(t*n*h-g),{isValid:y,value:m}=so(o(A*g)),R=o(m*f),b=o(m*R*A),_=o((i+i)*R);ze(_,s)&&(_=o(-_));let E=o(a*b),O=o(_*E);if(!y||ze(O,s)||E===Ji)throw new Error("invalid ristretto255 encoding 2");return new r(new ge.Point(_,E,Me,O))}static fromHex(e){return r.fromBytes(we("ristrettoHex",e,32))}static msm(e,t){return rn(r,ge.Point.Fn,e,t)}toBytes(){let{X:e,Y:t,Z:n,T:s}=this.ep,o=_t,i=b=>Ye.create(b),u=i(i(n+t)*i(n-t)),a=i(e*t),f=i(a*a),{value:h}=so(i(u*f)),g=i(h*u),A=i(h*a),y=i(g*A*s),m;if(ze(s*y,o)){let b=i(t*br),_=i(e*br);e=b,t=_,m=i(g*oa)}else m=A;ze(e*y,o)&&(t=i(-t));let R=i((n-t)*m);return ze(R,o)&&(R=i(-R)),Ye.toBytes(R)}equals(e){this.assertSame(e);let{X:t,Y:n}=this.ep,{X:s,Y:o}=e.ep,i=f=>Ye.create(f),u=i(t*o)===i(n*s),a=i(n*o)===i(t*s);return u||a}is0(){return this.equals(r.ZERO)}};Fe.BASE=new Fe(ge.Point.BASE);Fe.ZERO=new Fe(ge.Point.ZERO);Fe.Fp=Ye;Fe.Fn=na;var os=xe(Ts()),ue=xe(Ir());var It=xe(po()),c=xe(xr()),Ri=xe(xr());var Ta=1,La=2,va=3,Ca=4,Ba=5,xa=6,Pa=7,Da=8,Ua=9,za=10,Ma=-32700,Fa=-32603,Ka=-32602,Wa=-32601,$a=-32600,Va=-32016,Ga=-32015,qa=-32014,Ha=-32013,ja=-32012,Ya=-32011,Xa=-32010,Ja=-32009,Za=-32008,Qa=-32007,ec=-32006,tc=-32005,nc=-32004,rc=-32003,sc=-32002,oc=-32001,ic=28e5,ac=2800001,cc=2800002,uc=2800003,dc=2800004,lc=2800005,fc=2800006,hc=2800007,_c=2800008,pc=2800009,gc=2800010,yc=2800011,mc=323e4,Rc=32300001,Sc=3230002,Ec=3230003,bc=3230004,Ac=361e4,wc=3610001,Ic=3610002,Oc=3610003,Nc=3610004,kc=3610005,Tc=3610006,Lc=3610007,vc=3611e3,Cc=3704e3,Bc=3704001,xc=3704002,Pc=3704003,Dc=3704004,Uc=4128e3,zc=4128001,Mc=4128002,Fc=4615e3,Kc=4615001,Wc=4615002,$c=4615003,Vc=4615004,Gc=4615005,qc=4615006,Hc=4615007,jc=4615008,Yc=4615009,Xc=4615010,Jc=4615011,Zc=4615012,Qc=4615013,eu=4615014,tu=4615015,nu=4615016,ru=4615017,su=4615018,ou=4615019,iu=4615020,au=4615021,cu=4615022,uu=4615023,du=4615024,lu=4615025,fu=4615026,hu=4615027,_u=4615028,pu=4615029,gu=4615030,yu=4615031,mu=4615032,Ru=4615033,Su=4615034,Eu=4615035,bu=4615036,Au=4615037,wu=4615038,Iu=4615039,Ou=4615040,Nu=4615041,ku=4615042,Tu=4615043,Lu=4615044,vu=4615045,Cu=4615046,Bu=4615047,xu=4615048,Pu=4615049,Du=4615050,Uu=4615051,zu=4615052,Mu=4615053,Fu=4615054,Ku=5508e3,Wu=5508001,$u=5508002,Vu=5508003,Gu=5508004,qu=5508005,Hu=5508006,ju=5508007,Yu=5508008,Xu=5508009,Ju=5508010,Zu=5508011,Qu=5663e3,ed=5663001,td=5663002,nd=5663003,rd=5663004,sd=5663005,od=5663006,id=5663007,ad=5663008,cd=5663009,ud=5663010,dd=5663011,ld=5663012,fd=5663013,hd=5663014,_d=5663015,pd=5663016,gd=5663017,yd=5663018,md=5663019,Rd=5663020,Sd=705e4,Ed=7050001,bd=7050002,Ad=7050003,wd=7050004,Id=7050005,Od=7050006,Nd=7050007,kd=7050008,Td=7050009,Ld=7050010,vd=7050011,Cd=7050012,Bd=7050013,xd=7050014,Pd=7050015,Dd=7050016,Ud=7050017,zd=7050018,Md=7050019,Fd=7050020,Kd=7050021,Wd=7050022,$d=7050023,Vd=7050024,Gd=7050025,qd=7050026,Hd=7050027,jd=7050028,Yd=7050029,Xd=7050030,Jd=7050031,Zd=7050032,Qd=7050033,el=7050034,tl=7050035,nl=7050036,Pr=8078e3,Dr=8078001,go=8078002,yo=8078003,Ur=8078004,zr=8078005,Mr=8078006,rl=8078007,sl=8078008,ol=8078009,il=8078010,Fr=8078011,al=8078012,mo=8078013,Ro=8078014,cl=8078015,ul=8078016,dl=8078017,ll=8078018,fl=8078019,So=8078020,Eo=8078021,hl=8078022,_l=81e5,pl=8100001,gl=8100002,yl=8100003,ml=819e4,Rl=8190001,Sl=8190002,El=8190003,bl=8190004,Al=99e5,wl=9900001,Il=9900002,Ol=9900003,Nl=9900004;function bo(r){return Array.isArray(r)?"%5B"+r.map(bo).join("%2C%20")+"%5D":typeof r=="bigint"?`${r}n`:encodeURIComponent(String(r!=null&&Object.getPrototypeOf(r)===null?{...r}:r))}function kl([r,e]){return`${r}=${bo(e)}`}function Tl(r){let e=Object.entries(r).map(kl).join("&");return btoa(e)}var Kh={[mc]:"Account not found at address: $address",[bc]:"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",[Ec]:"Expected decoded account at address: $address",[Sc]:"Failed to decode account data at address: $address",[Rc]:"Accounts not found at addresses: $addresses",[pc]:"Unable to find a viable program address bump seed.",[cc]:"$putativeAddress is not a base58-encoded address.",[ic]:"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",[uc]:"The `CryptoKey` must be an `Ed25519` public key.",[yc]:"$putativeOffCurveAddress is not a base58-encoded off-curve address.",[_c]:"Invalid seeds; point must fall off the Ed25519 curve.",[dc]:"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",[fc]:"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",[hc]:"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",[lc]:"Expected program derived address bump to be in the range [0, 255], got: $bump.",[gc]:"Program address cannot end with PDA marker.",[ac]:"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",[Ca]:"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",[Ta]:"The network has progressed past the last block for which this transaction could have been committed.",[Pr]:"Codec [$codecDescription] cannot decode empty byte arrays.",[hl]:"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",[So]:"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",[zr]:"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",[Mr]:"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",[Ur]:"Encoder and decoder must either both be fixed-size or variable-size.",[sl]:"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",[go]:"Expected a fixed-size codec, got a variable-size one.",[mo]:"Codec [$codecDescription] expected a positive byte length, got $bytesLength.",[yo]:"Expected a variable-size codec, got a fixed-size one.",[fl]:"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",[Dr]:"Codec [$codecDescription] expected $expected bytes, got $bytesLength.",[ll]:"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",[ol]:"Invalid discriminated union variant. Expected one of [$variants], got $value.",[il]:"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",[cl]:"Invalid literal union variant. Expected one of [$variants], got $value.",[rl]:"Expected [$codecDescription] to have $expected items, got $actual.",[al]:"Invalid value $value for base $base with alphabet $alphabet.",[ul]:"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",[Fr]:"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",[Ro]:"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",[Eo]:"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",[dl]:"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",[vc]:"No random values implementation could be found.",[Yc]:"instruction requires an uninitialized account",[uu]:"instruction tries to borrow reference for an account which is already borrowed",[du]:"instruction left account with an outstanding borrowed reference",[au]:"program other than the account's owner changed the size of the account data",[Gc]:"account data too small for instruction",[cu]:"instruction expected an executable account",[Cu]:"An account does not have enough lamports to be rent-exempt",[xu]:"Program arithmetic overflowed",[vu]:"Failed to serialize or deserialize account data: $encodedData",[Fu]:"Builtin programs must consume compute units",[mu]:"Cross-program invocation call depth too deep",[wu]:"Computational budget exceeded",[fu]:"custom program error: #$code",[ru]:"instruction contains duplicate accounts",[lu]:"instruction modifications of multiply-passed account differ",[gu]:"executable accounts must be rent exempt",[_u]:"instruction changed executable accounts data",[pu]:"instruction changed the balance of an executable account",[su]:"instruction changed executable bit of an account",[eu]:"instruction modified data of an account it does not own",[Qc]:"instruction spent from the balance of an account it does not own",[Kc]:"generic instruction error",[Du]:"Provided owner is not allowed",[Tu]:"Account is immutable",[Lu]:"Incorrect authority provided",[Hc]:"incorrect program id for instruction",[qc]:"insufficient funds for instruction",[Vc]:"invalid account data for instruction",[Bu]:"Invalid account owner",[Wc]:"invalid program argument",[hu]:"program returned invalid error code",[$c]:"invalid instruction data",[Au]:"Failed to reallocate account data",[bu]:"Provided seeds do not result in a valid address",[Uu]:"Accounts data allocations exceeded the maximum allowed per transaction",[zu]:"Max accounts exceeded",[Mu]:"Max instruction trace length exceeded",[Eu]:"Length of the seed is too long for address generation",[Ru]:"An account required by the instruction is missing",[jc]:"missing required signature for instruction",[Zc]:"instruction illegally modified the program id of an account",[iu]:"insufficient account keys for instruction",[Iu]:"Cross-program invocation with unauthorized signer or writable account",[Ou]:"Failed to create program execution environment",[ku]:"Program failed to compile",[Nu]:"Program failed to complete",[nu]:"instruction modified data of a read-only account",[tu]:"instruction changed the balance of a read-only account",[Su]:"Cross-program invocation reentrancy not allowed for this instruction",[ou]:"instruction modified rent epoch of an account",[Jc]:"sum of account balances before and after instruction do not match",[Xc]:"instruction requires an initialized account",[Fc]:"",[yu]:"Unsupported program id",[Pu]:"Unsupported sysvar",[Uc]:"The instruction does not have any accounts.",[zc]:"The instruction does not have any data.",[Mc]:"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",[Ba]:"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",[La]:"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",[Il]:"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Nl]:"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",[wl]:"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Al]:"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Ol]:"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Fa]:"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",[Ka]:"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",[$a]:"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",[Wa]:"JSON-RPC error: The method does not exist / is not available ($__serverMessage)",[Ma]:"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",[ja]:"$__serverMessage",[oc]:"$__serverMessage",[nc]:"$__serverMessage",[qa]:"$__serverMessage",[Xa]:"$__serverMessage",[Ja]:"$__serverMessage",[Va]:"Minimum context slot has not been reached",[tc]:"Node is unhealthy; behind by $numSlotsBehind slots",[Za]:"No snapshot",[sc]:"Transaction simulation failed",[Qa]:"$__serverMessage",[Ya]:"Transaction history is not available from this node",[ec]:"$__serverMessage",[Ha]:"Transaction signature length mismatch",[rc]:"Transaction signature verification failure",[Ga]:"$__serverMessage",[Cc]:"Key pair bytes must be of length 64, got $byteLength.",[Bc]:"Expected private key bytes with length 32. Actual length: $actualLength.",[xc]:"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",[Dc]:"The provided private key does not match the provided public key.",[Pc]:"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",[xa]:"Lamports value must be in the range [0, 2e64-1]",[Pa]:"`$value` cannot be parsed as a `BigInt`",[za]:"$message",[Da]:"`$value` cannot be parsed as a `Number`",[va]:"No nonce account could be found at address `$nonceAccountAddress`",[ml]:"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",[Sl]:"WebSocket was closed before payload could be added to the send buffer",[El]:"WebSocket connection closed",[bl]:"WebSocket failed to connect",[Rl]:"Failed to obtain a subscription id from the server",[yl]:"Could not find an API plan for RPC method: `$method`",[_l]:"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",[gl]:"HTTP error ($statusCode): $message",[pl]:"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",[Ku]:"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",[Wu]:"The provided value does not implement the `KeyPairSigner` interface",[Vu]:"The provided value does not implement the `MessageModifyingSigner` interface",[Gu]:"The provided value does not implement the `MessagePartialSigner` interface",[$u]:"The provided value does not implement any of the `MessageSigner` interfaces",[Hu]:"The provided value does not implement the `TransactionModifyingSigner` interface",[ju]:"The provided value does not implement the `TransactionPartialSigner` interface",[Yu]:"The provided value does not implement the `TransactionSendingSigner` interface",[qu]:"The provided value does not implement any of the `TransactionSigner` interfaces",[Xu]:"More than one `TransactionSendingSigner` was identified.",[Ju]:"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",[Zu]:"Wallet account signers do not support signing multiple messages/transactions in a single operation",[Lc]:"Cannot export a non-extractable key.",[wc]:"No digest implementation could be found.",[Ac]:"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",[Ic]:`This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,[Oc]:"No signature verification implementation could be found.",[Nc]:"No key generation implementation could be found.",[kc]:"No signing implementation could be found.",[Tc]:"No key export implementation could be found.",[Ua]:"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",[Dd]:"Transaction processing left an account with an outstanding borrowed reference",[Ed]:"Account in use",[bd]:"Account loaded twice",[Ad]:"Attempt to debit an account but found no record of a prior credit.",[$d]:"Transaction loads an address table account that doesn't exist",[Nd]:"This transaction has already been processed",[kd]:"Blockhash not found",[Td]:"Loader call chain is too deep",[Pd]:"Transactions are currently disabled due to cluster maintenance",[Xd]:"Transaction contains a duplicate instruction ($index) that is not allowed",[Id]:"Insufficient funds for fee",[Jd]:"Transaction results in an account ($accountIndex) with insufficient funds for rent",[Od]:"This account may not be used to pay transaction fees",[vd]:"Transaction contains an invalid account reference",[Gd]:"Transaction loads an address table account with invalid data",[qd]:"Transaction address table lookup uses an invalid index",[Vd]:"Transaction loads an address table account with an invalid owner",[Qd]:"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",[Bd]:"This program may not be used for executing instructions",[Hd]:"Transaction leaves an account with a lower balance than rent-exempt minimum",[Md]:"Transaction loads a writable account that cannot be written",[Zd]:"Transaction exceeded max loaded accounts data size cap",[Ld]:"Transaction requires a fee but has no signature present",[wd]:"Attempt to load a program that does not exist",[tl]:"Execution of the program referenced by account at index $accountIndex is temporarily restricted.",[el]:"ResanitizationNeeded",[xd]:"Transaction failed to sanitize accounts offsets correctly",[Cd]:"Transaction did not pass signature verification",[Wd]:"Transaction locked too many accounts",[nl]:"Sum of account balances before and after transaction do not match",[Sd]:"The transaction failed with the error `$errorName`",[zd]:"Transaction version is unsupported",[Kd]:"Transaction would exceed account data limit within the block",[Yd]:"Transaction would exceed total account data limit",[Fd]:"Transaction would exceed max account limit within the block",[Ud]:"Transaction would exceed max Block Cost Limit",[jd]:"Transaction would exceed max Vote Cost Limit",[_d]:"Attempted to sign a transaction with an address that is not a signer for it",[ud]:"Transaction is missing an address at index: $index.",[pd]:"Transaction has no expected signers therefore it cannot be encoded",[Rd]:"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",[td]:"Transaction does not have a blockhash lifetime",[nd]:"Transaction is not a durable nonce transaction",[sd]:"Contents of these address lookup tables unknown: $lookupTableAddresses",[od]:"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",[ad]:"No fee payer set in CompiledTransaction",[id]:"Could not find program address at index $index",[yd]:"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",[md]:"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",[dd]:"Transaction is missing a fee payer.",[ld]:"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",[hd]:"Transaction first instruction is not advance nonce account instruction.",[fd]:"Transaction with no instructions cannot be durable nonce transaction.",[Qu]:"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",[ed]:"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",[gd]:"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",[cd]:"Transaction is missing signatures for addresses: $addresses.",[rd]:"Transaction version must be in the range [0, 127]. `$actualVersion` given"};function Ll(r,e={}){{let t=`Solana error #${r}; Decode this error by running \`npx @solana/errors decode -- ${r}`;return Object.keys(e).length&&(t+=` '${Tl(e)}'`),`${t}\``}}var Ze=class extends Error{cause=this.cause;context;constructor(...[r,e]){let t,n;if(e){let{cause:o,...i}=e;o&&(n={cause:o}),Object.keys(i).length>0&&(t=i)}let s=Ll(r,t);super(s,n),this.context={__code:r,...t},this.name="SolanaError"}};function vl(r,e){return"fixedSize"in e?e.fixedSize:e.getSizeFromValue(r)}function Ao(r){return Object.freeze({...r,encode:e=>{let t=new Uint8Array(vl(e,r));return r.write(e,t,0),t}})}function wo(r){return Object.freeze({...r,decode:(e,t=0)=>r.read(e,t)[0]})}function Rt(r){return"fixedSize"in r&&typeof r.fixedSize=="number"}function Io(r,e){if(Rt(r)!==Rt(e))throw new Ze(Ur);if(Rt(r)&&Rt(e)&&r.fixedSize!==e.fixedSize)throw new Ze(zr,{decoderFixedSize:e.fixedSize,encoderFixedSize:r.fixedSize});if(!Rt(r)&&!Rt(e)&&r.maxSize!==e.maxSize)throw new Ze(Mr,{decoderMaxSize:e.maxSize,encoderMaxSize:r.maxSize});return{...e,...r,decode:e.decode,encode:r.encode,read:e.read,write:r.write}}function Oo(r,e,t=0){if(e.length-t<=0)throw new Ze(Pr,{codecDescription:r})}function No(r,e,t,n=0){let s=t.length-n;if(s<e)throw new Ze(Dr,{bytesLength:s,codecDescription:r,expected:e})}function Cl(r,e,t,n){if(n<e||n>t)throw new Ze(Fr,{codecDescription:r,max:t,min:e,value:n})}function ko(r){return r?.endian!==1}function Bl(r){return Ao({fixedSize:r.size,write(e,t,n){r.range&&Cl(r.name,r.range[0],r.range[1],e);let s=new ArrayBuffer(r.size);return r.set(new DataView(s),e,ko(r.config)),t.set(new Uint8Array(s),n),n+r.size}})}function xl(r){return wo({fixedSize:r.size,read(e,t=0){Oo(r.name,e,t),No(r.name,r.size,e,t);let n=new DataView(Pl(e,t,r.size));return[r.get(n,ko(r.config)),t+r.size]}})}function Pl(r,e,t){let n=r.byteOffset+(e??0),s=t??r.byteLength;return r.buffer.slice(n,n+s)}var Kr=(r={})=>Bl({config:r,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),Dl=(r={})=>xl({config:r,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),To=(r={})=>Io(Kr(r),Dl(r));var Wr=class extends TypeError{constructor(e,t){let n,{message:s,explanation:o,...i}=e,{path:u}=e,a=u.length===0?s:`At path: ${u.join(".")} -- ${s}`;super(o??a),o!=null&&(this.cause=a),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}};function Ul(r){return Ft(r)&&typeof r[Symbol.iterator]=="function"}function Ft(r){return typeof r=="object"&&r!=null}function Mn(r){return Ft(r)&&!Array.isArray(r)}function ke(r){return typeof r=="symbol"?r.toString():typeof r=="string"?JSON.stringify(r):`${r}`}function zl(r){let{done:e,value:t}=r.next();return e?void 0:t}function Ml(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});let{path:s,branch:o}=e,{type:i}=t,{refinement:u,message:a=`Expected a value of type \`${i}\`${u?` with refinement \`${u}\``:""}, but received: \`${ke(n)}\``}=r;return{value:n,type:i,refinement:u,key:s[s.length-1],path:s,branch:o,...r,message:a}}function*Lo(r,e,t,n){Ul(r)||(r=[r]);for(let s of r){let o=Ml(s,e,t,n);o&&(yield o)}}function*$r(r,e,t={}){let{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,u={path:n,branch:s,mask:i};o&&(r=e.coercer(r,u));let a="valid";for(let f of e.validator(r,u))f.explanation=t.message,a="not_valid",yield[f,void 0];for(let[f,h,g]of e.entries(r,u)){let A=$r(h,g,{path:f===void 0?n:[...n,f],branch:f===void 0?s:[...s,h],coerce:o,mask:i,message:t.message});for(let y of A)y[0]?(a=y[0].refinement!=null?"not_refined":"not_valid",yield[y[0],void 0]):o&&(h=y[1],f===void 0?r=h:r instanceof Map?r.set(f,h):r instanceof Set?r.add(h):Ft(r)&&(h!==void 0||f in r)&&(r[f]=h))}if(a!=="not_valid")for(let f of e.refiner(r,u))f.explanation=t.message,a="not_refined",yield[f,void 0];a==="valid"&&(yield[void 0,r])}var Ie=class{constructor(e){let{type:t,schema:n,validator:s,refiner:o,coercer:i=a=>a,entries:u=function*(){}}=e;this.type=t,this.schema=n,this.entries=u,this.coercer=i,s?this.validator=(a,f)=>{let h=s(a,f);return Lo(h,f,this,a)}:this.validator=()=>[],o?this.refiner=(a,f)=>{let h=o(a,f);return Lo(h,f,this,a)}:this.refiner=()=>[]}assert(e,t){return vo(e,this,t)}create(e,t){return St(e,this,t)}is(e){return Co(e,this)}mask(e,t){return Fl(e,this,t)}validate(e,t={}){return Kt(e,this,t)}};function vo(r,e,t){let n=Kt(r,e,{message:t});if(n[0])throw n[0]}function St(r,e,t){let n=Kt(r,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function Fl(r,e,t){let n=Kt(r,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Co(r,e){return!Kt(r,e)[0]}function Kt(r,e,t={}){let n=$r(r,e,t),s=zl(n);return s[0]?[new Wr(s[0],function*(){for(let i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function at(r,e){return new Ie({type:r,schema:null,validator:e})}function Bo(){return at("any",()=>!0)}function w(r){return new Ie({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(let[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${ke(e)}`}})}function Te(){return at("boolean",r=>typeof r=="boolean")}function Fn(r){return at("instance",e=>e instanceof r||`Expected a \`${r.name}\` instance, but received: ${ke(e)}`)}function j(r){let e=ke(r),t=typeof r;return new Ie({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||`Expected the literal \`${e}\`, but received: ${ke(n)}`}})}function Kl(){return at("never",()=>!1)}function I(r){return new Ie({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function d(){return at("number",r=>typeof r=="number"&&!isNaN(r)||`Expected a number, but received: ${ke(r)}`)}function k(r){return new Ie({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function Vr(r,e){return new Ie({type:"record",schema:null,*entries(t){if(Ft(t))for(let n in t){let s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return Mn(t)||`Expected an object, but received: ${ke(t)}`},coercer(t){return Mn(t)?{...t}:t}})}function S(){return at("string",r=>typeof r=="string"||`Expected a string, but received: ${ke(r)}`)}function Kn(r){let e=Kl();return new Ie({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){let n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${ke(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function p(r){let e=Object.keys(r);return new Ie({type:"type",schema:r,*entries(t){if(Ft(t))for(let n of e)yield[n,t[n],r[n]]},validator(t){return Mn(t)||`Expected an object, but received: ${ke(t)}`},coercer(t){return Mn(t)?{...t}:t}})}function re(r){let e=r.map(t=>t.type).join(" | ");return new Ie({type:"union",schema:null,coercer(t,n){for(let s of r){let[o,i]=s.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){let s=[];for(let o of r){let[...i]=$r(t,o,n),[u]=i;if(u[0])for(let[a]of i)a&&s.push(a);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${ke(t)}`,...s]}})}function ct(){return at("unknown",()=>!0)}function Et(r,e,t){return new Ie({...r,coercer:(n,s)=>Co(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}var pf=xe(ri());var _f=xe(lr(),1);var ii=xe(oi(),1);var j_=ge.utils.randomPrivateKey,ai=()=>{let r=ge.utils.randomPrivateKey(),e=is(r),t=new Uint8Array(64);return t.set(r),t.set(e,32),{publicKey:e,secretKey:t}},is=ge.getPublicKey;function ci(r){try{return ge.ExtendedPoint.fromHex(r),!0}catch{return!1}}var Ss=(r,e)=>ge.sign(r,e.slice(0,32)),gf=ge.verify,U=r=>L.Buffer.isBuffer(r)?r:r instanceof Uint8Array?L.Buffer.from(r.buffer,r.byteOffset,r.byteLength):L.Buffer.from(r),as=class{constructor(e){Object.assign(this,e)}encode(){return L.Buffer.from((0,It.serialize)(Yn,this))}static decode(e){return(0,It.deserialize)(Yn,this,e)}static decodeUnchecked(e){return(0,It.deserializeUnchecked)(Yn,this,e)}};var Yn=new Map,Si,yf=32,rt=32;function mf(r){return r._bn!==void 0}var ui=1,C=class r extends as{constructor(e){if(super({}),this._bn=void 0,mf(e))this._bn=e._bn;else{if(typeof e=="string"){let t=ue.default.decode(e);if(t.length!=rt)throw new Error("Invalid public key input");this._bn=new os.default(t)}else this._bn=new os.default(e);if(this._bn.byteLength()>rt)throw new Error("Invalid public key input")}}static unique(){let e=new r(ui);return ui+=1,new r(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return ue.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){let e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){let e=this._bn.toArrayLike(L.Buffer);if(e.length===rt)return e;let t=L.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){let s=L.Buffer.concat([e.toBuffer(),L.Buffer.from(t),n.toBuffer()]),o=mr(s);return new r(o)}static createProgramAddressSync(e,t){let n=L.Buffer.alloc(0);e.forEach(function(o){if(o.length>yf)throw new TypeError("Max seed length exceeded");n=L.Buffer.concat([n,U(o)])}),n=L.Buffer.concat([n,t.toBuffer(),L.Buffer.from("ProgramDerivedAddress")]);let s=mr(n);if(ci(s))throw new Error("Invalid seeds, address must fall off the curve");return new r(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{let o=e.concat(L.Buffer.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){let t=new r(e);return ci(t.toBytes())}};Si=C;C.default=new Si("11111111111111111111111111111111");Yn.set(C,{kind:"struct",fields:[["_bn","u256"]]});var Y_=new C("BPFLoader1111111111111111111111111111111111"),ut=1232,Es=127,Xn=64,cs=class extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}};Object.defineProperty(cs.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});var us=class extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}};Object.defineProperty(us.prototype,"name",{value:"TransactionExpiredTimeoutError"});var ds=class extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}};Object.defineProperty(ds.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});var At=class{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){let e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(let t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");let n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});let s=o=>{let i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}},B=(r="publicKey")=>c.blob(32,r),Rf=(r="signature")=>c.blob(64,r),bt=(r="string")=>{let e=c.struct([c.u32("length"),c.u32("lengthPadding"),c.blob(c.offset(c.u32(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,u)=>{let a={chars:L.Buffer.from(o,"utf8")};return n(a,i,u)},s.alloc=o=>c.u32().span+c.u32().span+L.Buffer.from(o,"utf8").length,s},Sf=(r="authorized")=>c.struct([B("staker"),B("withdrawer")],r),Ef=(r="lockup")=>c.struct([c.ns64("unixTimestamp"),c.ns64("epoch"),B("custodian")],r),bf=(r="voteInit")=>c.struct([B("nodePubkey"),B("authorizedVoter"),B("authorizedWithdrawer"),c.u8("commission")],r),Af=(r="voteAuthorizeWithSeedArgs")=>c.struct([c.u32("voteAuthorizationType"),B("currentAuthorityDerivedKeyOwnerPubkey"),bt("currentAuthorityDerivedKeySeed"),B("newAuthorized")],r);function Ei(r,e){let t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){let o=e[s.property];if(Array.isArray(o))return o.length*t(s.elementLayout)}else if("fields"in s)return Ei({layout:s},e[s.property]);return 0},n=0;return r.layout.fields.forEach(s=>{n+=t(s)}),n}function Se(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,(n&128)===0)break}return e}function Ee(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function q(r,e){if(!r)throw new Error(e||"Assertion failed")}var Jn=class r{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){let n=new Map,s=i=>{let u=i.toBase58(),a=n.get(u);return a===void 0&&(a={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(u,a)),a},o=s(t);o.isSigner=!0,o.isWritable=!0;for(let i of e){s(i.programId).isInvoked=!0;for(let u of i.keys){let a=s(u.pubkey);a.isSigner||=u.isSigner,a.isWritable||=u.isWritable}}return new r(t,n)}getMessageComponents(){let e=[...this.keyMetaMap.entries()];q(e.length<=256,"Max static account keys length exceeded");let t=e.filter(([,a])=>a.isSigner&&a.isWritable),n=e.filter(([,a])=>a.isSigner&&!a.isWritable),s=e.filter(([,a])=>!a.isSigner&&a.isWritable),o=e.filter(([,a])=>!a.isSigner&&!a.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{q(t.length>0,"Expected at least one writable signer key");let[a]=t[0];q(a===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}let u=[...t.map(([a])=>new C(a)),...n.map(([a])=>new C(a)),...s.map(([a])=>new C(a)),...o.map(([a])=>new C(a))];return[i,u]}extractTableLookup(e){let[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){let n=new Array,s=new Array;for(let[o,i]of this.keyMetaMap.entries())if(t(i)){let u=new C(o),a=e.findIndex(f=>f.equals(u));a>=0&&(q(a<256,"Max lookup table index exceeded"),n.push(a),s.push(u),this.keyMetaMap.delete(o))}return[n,s]}},bi="Reached end of buffer unexpectedly";function Ve(r){if(r.length===0)throw new Error(bi);return r.shift()}function be(r,...e){let[t]=e;if(e.length===2?t+(e[1]??0)>r.length:t>=r.length)throw new Error(bi);return r.splice(...e)}var Yt=class r{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new C(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ue.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new At(this.staticAccountKeys)}static compile(e){let t=Jn.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new At(s).compileInstructions(e.instructions).map(u=>({programIdIndex:u.programIdIndex,accounts:u.accountKeyIndexes,data:ue.default.encode(u.data)}));return new r({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){let n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{let n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){let e=this.accountKeys.length,t=[];Ee(t,e);let n=this.instructions.map(g=>{let{accounts:A,programIdIndex:y}=g,m=Array.from(ue.default.decode(g.data)),R=[];Ee(R,A.length);let b=[];return Ee(b,m.length),{programIdIndex:y,keyIndicesCount:L.Buffer.from(R),keyIndices:A,dataLength:L.Buffer.from(b),data:m}}),s=[];Ee(s,n.length);let o=L.Buffer.alloc(ut);L.Buffer.from(s).copy(o);let i=s.length;n.forEach(g=>{let y=c.struct([c.u8("programIdIndex"),c.blob(g.keyIndicesCount.length,"keyIndicesCount"),c.seq(c.u8("keyIndex"),g.keyIndices.length,"keyIndices"),c.blob(g.dataLength.length,"dataLength"),c.seq(c.u8("userdatum"),g.data.length,"data")]).encode(g,o,i);i+=y}),o=o.slice(0,i);let u=c.struct([c.blob(1,"numRequiredSignatures"),c.blob(1,"numReadonlySignedAccounts"),c.blob(1,"numReadonlyUnsignedAccounts"),c.blob(t.length,"keyCount"),c.seq(B("key"),e,"keys"),B("recentBlockhash")]),a={numRequiredSignatures:L.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:L.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:L.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:L.Buffer.from(t),keys:this.accountKeys.map(g=>U(g.toBytes())),recentBlockhash:ue.default.decode(this.recentBlockhash)},f=L.Buffer.alloc(2048),h=u.encode(a,f);return o.copy(f,h),f.slice(0,h+o.length)}static from(e){let t=[...e],n=Ve(t);if(n!==(n&Es))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");let s=Ve(t),o=Ve(t),i=Se(t),u=[];for(let A=0;A<i;A++){let y=be(t,0,rt);u.push(new C(L.Buffer.from(y)))}let a=be(t,0,rt),f=Se(t),h=[];for(let A=0;A<f;A++){let y=Ve(t),m=Se(t),R=be(t,0,m),b=Se(t),_=be(t,0,b),E=ue.default.encode(L.Buffer.from(_));h.push({programIdIndex:y,accounts:R,data:E})}let g={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:ue.default.encode(L.Buffer.from(a)),accountKeys:u,instructions:h};return new r(g)}},ls=class r{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(let t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new At(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){let s=e-n,o=this.addressTableLookups.reduce((i,u)=>i+u.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){let s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{let s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){let t={writable:[],readonly:[]};for(let n of this.addressTableLookups){let s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(let o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(let o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){let t=Jn.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(let h of o){let g=t.extractTableLookup(h);if(g!==void 0){let[A,{writable:y,readonly:m}]=g;n.push(A),s.writable.push(...y),s.readonly.push(...m)}}let[i,u]=t.getMessageComponents(),f=new At(u,s).compileInstructions(e.instructions);return new r({header:i,staticAccountKeys:u,recentBlockhash:e.recentBlockhash,compiledInstructions:f,addressTableLookups:n})}serialize(){let e=Array();Ee(e,this.staticAccountKeys.length);let t=this.serializeInstructions(),n=Array();Ee(n,this.compiledInstructions.length);let s=this.serializeAddressTableLookups(),o=Array();Ee(o,this.addressTableLookups.length);let i=c.struct([c.u8("prefix"),c.struct([c.u8("numRequiredSignatures"),c.u8("numReadonlySignedAccounts"),c.u8("numReadonlyUnsignedAccounts")],"header"),c.blob(e.length,"staticAccountKeysLength"),c.seq(B(),this.staticAccountKeys.length,"staticAccountKeys"),B("recentBlockhash"),c.blob(n.length,"instructionsLength"),c.blob(t.length,"serializedInstructions"),c.blob(o.length,"addressTableLookupsLength"),c.blob(s.length,"serializedAddressTableLookups")]),u=new Uint8Array(ut),f=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(h=>h.toBytes()),recentBlockhash:ue.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},u);return u.slice(0,f)}serializeInstructions(){let e=0,t=new Uint8Array(ut);for(let n of this.compiledInstructions){let s=Array();Ee(s,n.accountKeyIndexes.length);let o=Array();Ee(o,n.data.length);let i=c.struct([c.u8("programIdIndex"),c.blob(s.length,"encodedAccountKeyIndexesLength"),c.seq(c.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),c.blob(o.length,"encodedDataLength"),c.blob(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0,t=new Uint8Array(ut);for(let n of this.addressTableLookups){let s=Array();Ee(s,n.writableIndexes.length);let o=Array();Ee(o,n.readonlyIndexes.length);let i=c.struct([B("accountKey"),c.blob(s.length,"encodedWritableIndexesLength"),c.seq(c.u8(),n.writableIndexes.length,"writableIndexes"),c.blob(o.length,"encodedReadonlyIndexesLength"),c.seq(c.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e],n=Ve(t),s=n&Es;q(n!==s,"Expected versioned message but received legacy message");let o=s;q(o===0,`Expected versioned message with version 0 but found version ${o}`);let i={numRequiredSignatures:Ve(t),numReadonlySignedAccounts:Ve(t),numReadonlyUnsignedAccounts:Ve(t)},u=[],a=Se(t);for(let m=0;m<a;m++)u.push(new C(be(t,0,rt)));let f=ue.default.encode(be(t,0,rt)),h=Se(t),g=[];for(let m=0;m<h;m++){let R=Ve(t),b=Se(t),_=be(t,0,b),E=Se(t),O=new Uint8Array(be(t,0,E));g.push({programIdIndex:R,accountKeyIndexes:_,data:O})}let A=Se(t),y=[];for(let m=0;m<A;m++){let R=new C(be(t,0,rt)),b=Se(t),_=be(t,0,b),E=Se(t),O=be(t,0,E);y.push({accountKey:R,writableIndexes:_,readonlyIndexes:O})}return new r({header:i,staticAccountKeys:u,recentBlockhash:f,compiledInstructions:g,addressTableLookups:y})}},Ai={deserializeMessageVersion(r){let e=r[0],t=e&Es;return t===e?"legacy":t},deserialize:r=>{let e=Ai.deserializeMessageVersion(r);if(e==="legacy")return Yt.from(r);if(e===0)return ls.deserialize(r);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};var wf=L.Buffer.alloc(Xn).fill(0),V=class{constructor(e){this.keys=void 0,this.programId=void 0,this.data=L.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}},Y=class r{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){let{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){let{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{let{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new V(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1;let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let R=0;R<t.length;R++)if(t[R].programId===void 0)throw new Error(`Transaction instruction index ${R} has undefined program id`);let s=[],o=[];t.forEach(R=>{R.keys.forEach(_=>{o.push({..._})});let b=R.programId.toString();s.includes(b)||s.push(b)}),s.forEach(R=>{o.push({pubkey:new C(R),isSigner:!1,isWritable:!1})});let i=[];o.forEach(R=>{let b=R.pubkey.toString(),_=i.findIndex(E=>E.pubkey.toString()===b);_>-1?(i[_].isWritable=i[_].isWritable||R.isWritable,i[_].isSigner=i[_].isSigner||R.isSigner):i.push(R)}),i.sort(function(R,b){if(R.isSigner!==b.isSigner)return R.isSigner?-1:1;if(R.isWritable!==b.isWritable)return R.isWritable?-1:1;let _={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return R.pubkey.toBase58().localeCompare(b.pubkey.toBase58(),"en",_)});let u=i.findIndex(R=>R.pubkey.equals(n));if(u>-1){let[R]=i.splice(u,1);R.isSigner=!0,R.isWritable=!0,i.unshift(R)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(let R of this.signatures){let b=i.findIndex(_=>_.pubkey.equals(R.publicKey));if(b>-1)i[b].isSigner||(i[b].isSigner=!0);else throw new Error(`unknown signer: ${R.publicKey.toString()}`)}let a=0,f=0,h=0,g=[],A=[];i.forEach(({pubkey:R,isSigner:b,isWritable:_})=>{b?(g.push(R.toString()),a+=1,_||(f+=1)):(A.push(R.toString()),_||(h+=1))});let y=g.concat(A),m=t.map(R=>{let{data:b,programId:_}=R;return{programIdIndex:y.indexOf(_.toString()),accounts:R.keys.map(E=>y.indexOf(E.pubkey.toString())),data:ue.default.encode(b)}});return m.forEach(R=>{q(R.programIdIndex>=0),R.accounts.forEach(b=>q(b>=0))}),new Yt({header:{numRequiredSignatures:a,numReadonlySignedAccounts:f,numReadonlyUnsignedAccounts:h},accountKeys:y,recentBlockhash:e,instructions:m})}_compile(){let e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");let t=new Set;this.signatures=e.filter(n=>{let s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));let s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}let s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){let n=e.serialize();t.forEach(s=>{let o=Ss(n,s.secretKey);this._addSignature(s.publicKey,U(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){q(t.length===64);let n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=L.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){let n={};for(let{signature:s,publicKey:o}of this.signatures)s===null?t&&(n.missing||=[]).push(o):gf(s,e,o.toBytes())||(n.invalid||=[]).push(o);return n.invalid||n.missing?n:void 0}serialize(e){let{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){let o=this._getMessageSignednessErrors(s,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(u=>u.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(u=>u.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(e){let{signatures:t}=this,n=[];Ee(n,t.length);let s=n.length+t.length*64+e.length,o=L.Buffer.alloc(s);return q(t.length<256),L.Buffer.from(n).copy(o,0),t.forEach(({signature:i},u)=>{i!==null&&(q(i.length===64,"signature has invalid length"),L.Buffer.from(i).copy(o,n.length+u*64))}),e.copy(o,n.length+t.length*64),q(o.length<=ut,`Transaction too large: ${o.length} > ${ut}`),o}get keys(){return q(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return q(this.instructions.length===1),this.instructions[0].programId}get data(){return q(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e],n=Se(t),s=[];for(let o=0;o<n;o++){let i=be(t,0,Xn);s.push(ue.default.encode(L.Buffer.from(i)))}return r.populate(Yt.from(t),s)}static populate(e,t=[]){let n=new r;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{let i={signature:s==ue.default.encode(wf)?null:ue.default.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{let o=s.accounts.map(i=>{let u=e.accountKeys[i];return{pubkey:u,isSigner:n.signatures.some(a=>a.publicKey.toString()===u.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new V({keys:o,programId:e.accountKeys[s.programIdIndex],data:ue.default.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}};var Zn=class r{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)q(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{let n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array(Xn));this.signatures=n}this.message=e}serialize(){let e=this.message.serialize(),t=Array();Ee(t,this.signatures.length);let n=c.struct([c.blob(t.length,"encodedSignaturesLength"),c.seq(Rf(),this.signatures.length,"signatures"),c.blob(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e],n=[],s=Se(t);for(let i=0;i<s;i++)n.push(new Uint8Array(be(t,0,Xn)));let o=Ai.deserialize(new Uint8Array(t));return new r(o,n)}sign(e){let t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(let s of e){let o=n.findIndex(i=>i.equals(s.publicKey));q(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=Ss(t,s.secretKey)}}addSignature(e,t){q(t.byteLength===64,"Signature must be 64 bytes long");let s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));q(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}},If=160,Of=64,Nf=If/Of,kf=1e3/Nf,$e=new C("SysvarC1ock11111111111111111111111111111111"),X_=new C("SysvarEpochSchedu1e111111111111111111111111"),J_=new C("Sysvar1nstructions1111111111111111111111111"),ts=new C("SysvarRecentB1ockHashes11111111111111111111"),Xt=new C("SysvarRent111111111111111111111111111111111"),Z_=new C("SysvarRewards111111111111111111111111111111"),Q_=new C("SysvarS1otHashes111111111111111111111111111"),ep=new C("SysvarS1otHistory11111111111111111111111111"),ns=new C("SysvarStakeHistory1111111111111111111111111"),fs=class extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:s}){let o=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.",u;switch(e){case"send":u=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":u=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:u=`Unknown action '${(a=>a)(e)}'`}super(u),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){let e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){let o=s.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}};async function di(r,e,t,n){let s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=await r.sendTransaction(e,t,s),i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await r.confirmTransaction({abortSignal:n?.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){let{nonceInstruction:u}=e.nonceInfo,a=u.keys[0].pubkey;i=(await r.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:a,nonceValue:e.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else n?.abortSignal!=null,i=(await r.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw o!=null?new fs({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function Tf(r){return new Promise(e=>setTimeout(e,r))}function P(r,e){let t=r.layout.span>=0?r.layout.span:Ei(r,e),n=L.Buffer.alloc(t),s=Object.assign({instruction:r.index},e);return r.layout.encode(s,n),n}var Lf=c.nu64("lamportsPerSignature"),vf=c.struct([c.u32("version"),c.u32("state"),B("authorizedPubkey"),B("nonce"),c.struct([Lf],"feeCalculator")]),li=vf.span;function wt(r){let e=(0,Ri.blob)(8,r),t=e.decode.bind(e),n=e.encode.bind(e),s=e,o=To();return s.decode=(i,u)=>{let a=t(i,u);return o.decode(a)},s.encode=(i,u,a)=>{let f=o.encode(i);return n(f,u,a)},s}var Oe=Object.freeze({Create:{index:0,layout:c.struct([c.u32("instruction"),c.ns64("lamports"),c.ns64("space"),B("programId")])},Assign:{index:1,layout:c.struct([c.u32("instruction"),B("programId")])},Transfer:{index:2,layout:c.struct([c.u32("instruction"),wt("lamports")])},CreateWithSeed:{index:3,layout:c.struct([c.u32("instruction"),B("base"),bt("seed"),c.ns64("lamports"),c.ns64("space"),B("programId")])},AdvanceNonceAccount:{index:4,layout:c.struct([c.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:c.struct([c.u32("instruction"),c.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:c.struct([c.u32("instruction"),B("authorized")])},AuthorizeNonceAccount:{index:7,layout:c.struct([c.u32("instruction"),B("authorized")])},Allocate:{index:8,layout:c.struct([c.u32("instruction"),c.ns64("space")])},AllocateWithSeed:{index:9,layout:c.struct([c.u32("instruction"),B("base"),bt("seed"),c.ns64("space"),B("programId")])},AssignWithSeed:{index:10,layout:c.struct([c.u32("instruction"),B("base"),bt("seed"),B("programId")])},TransferWithSeed:{index:11,layout:c.struct([c.u32("instruction"),wt("lamports"),bt("seed"),B("programId")])},UpgradeNonceAccount:{index:12,layout:c.struct([c.u32("instruction")])}}),_e=class r{constructor(){}static createAccount(e){let t=Oe.Create,n=P(t,{lamports:e.lamports,space:e.space,programId:U(e.programId.toBuffer())});return new V({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){let s=Oe.TransferWithSeed;t=P(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:U(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{let s=Oe.Transfer;t=P(s,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new V({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){let s=Oe.AssignWithSeed;t=P(s,{base:U(e.basePubkey.toBuffer()),seed:e.seed,programId:U(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let s=Oe.Assign;t=P(s,{programId:U(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new V({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){let t=Oe.CreateWithSeed,n=P(t,{base:U(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:U(e.programId.toBuffer())}),s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new V({keys:s,programId:this.programId,data:n})}static createNonceAccount(e){let t=new Y;"basePubkey"in e&&"seed"in e?t.add(r.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:li,programId:this.programId})):t.add(r.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:li,programId:this.programId}));let n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){let t=Oe.InitializeNonceAccount,n=P(t,{authorized:U(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ts,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new V(s)}static nonceAdvance(e){let t=Oe.AdvanceNonceAccount,n=P(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ts,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new V(s)}static nonceWithdraw(e){let t=Oe.WithdrawNonceAccount,n=P(t,{lamports:e.lamports});return new V({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ts,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){let t=Oe.AuthorizeNonceAccount,n=P(t,{authorized:U(e.newAuthorizedPubkey.toBuffer())});return new V({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){let s=Oe.AllocateWithSeed;t=P(s,{base:U(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:U(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let s=Oe.Allocate;t=P(s,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new V({keys:n,programId:this.programId,data:t})}};_e.programId=new C("11111111111111111111111111111111");var Cf=ut-300,hs=class r{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/r.chunkSize)+1+1)}static async load(e,t,n,s,o){{let g=await e.getMinimumBalanceForRentExemption(o.length),A=await e.getAccountInfo(n.publicKey,"confirmed"),y=null;if(A!==null){if(A.executable)return!1;A.data.length!==o.length&&(y=y||new Y,y.add(_e.allocate({accountPubkey:n.publicKey,space:o.length}))),A.owner.equals(s)||(y=y||new Y,y.add(_e.assign({accountPubkey:n.publicKey,programId:s}))),A.lamports<g&&(y=y||new Y,y.add(_e.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:g-A.lamports})))}else y=new Y().add(_e.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:g>0?g:1,space:o.length,programId:s}));y!==null&&await di(e,y,[t,n],{commitment:"confirmed"})}let i=c.struct([c.u32("instruction"),c.u32("offset"),c.u32("bytesLength"),c.u32("bytesLengthPadding"),c.seq(c.u8("byte"),c.offset(c.u32(),-8),"bytes")]),u=r.chunkSize,a=0,f=o,h=[];for(;f.length>0;){let g=f.slice(0,u),A=L.Buffer.alloc(u+16);i.encode({instruction:0,offset:a,bytes:g,bytesLength:0,bytesLengthPadding:0},A);let y=new Y().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:s,data:A});h.push(di(e,y,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await Tf(1e3/4),a+=u,f=f.slice(u)}await Promise.all(h);{let g=c.struct([c.u32("instruction")]),A=L.Buffer.alloc(g.span);g.encode({instruction:1},A);let y=new Y().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1}],programId:s,data:A}),m="processed",R=await e.sendTransaction(y,[t,n],{preflightCommitment:m}),{context:b,value:_}=await e.confirmTransaction({signature:R,lastValidBlockHeight:y.lastValidBlockHeight,blockhash:y.recentBlockhash},m);if(_.err)throw new Error(`Transaction ${R} failed (${JSON.stringify(_)})`);for(;;){try{if(await e.getSlot({commitment:m})>b.slot)break}catch{}await new Promise(E=>setTimeout(E,Math.round(kf/2)))}}return!0}};hs.chunkSize=Cf;var tp=new C("BPFLoader2111111111111111111111111111111111");var np=globalThis.fetch;var rp={index:1,layout:c.struct([c.u32("typeIndex"),wt("deactivationSlot"),c.nu64("lastExtendedSlot"),c.u8("lastExtendedStartIndex"),c.u8(),c.seq(B(),c.offset(c.u8(),-1),"authority")])};var J=Et(Fn(C),S(),r=>new C(r)),wi=Kn([S(),j("base64")]),bs=Et(Fn(L.Buffer),wi,r=>L.Buffer.from(r[0],"base64")),sp=30*1e3;function Ii(r){return re([p({jsonrpc:j("2.0"),id:S(),result:r}),p({jsonrpc:j("2.0"),id:S(),error:p({code:ct(),message:S(),data:k(Bo())})})])}var Bf=Ii(ct());function G(r){return Et(Ii(r),Bf,e=>"error"in e?e:{...e,result:St(e.result,r)})}function Le(r){return G(p({context:p({slot:d()}),value:r}))}function nr(r){return p({context:p({slot:d()}),value:r})}var xf=p({foundation:d(),foundationTerm:d(),initial:d(),taper:d(),terminal:d()}),op=G(w(I(p({epoch:d(),effectiveSlot:d(),amount:d(),postBalance:d(),commission:k(I(d()))})))),Pf=w(p({slot:d(),prioritizationFee:d()})),Df=p({total:d(),validator:d(),foundation:d(),epoch:d()}),Uf=p({epoch:d(),slotIndex:d(),slotsInEpoch:d(),absoluteSlot:d(),blockHeight:k(d()),transactionCount:k(d())}),zf=p({slotsPerEpoch:d(),leaderScheduleSlotOffset:d(),warmup:Te(),firstNormalEpoch:d(),firstNormalSlot:d()}),Mf=Vr(S(),w(d())),dt=I(re([p({}),S()])),Ff=p({err:dt}),Kf=j("receivedSignature"),ip=p({"solana-core":S(),"feature-set":k(d())}),Wf=p({program:S(),programId:J,parsed:ct()}),$f=p({programId:J,accounts:w(J),data:S()}),ap=Le(p({err:I(re([p({}),S()])),logs:I(w(S())),accounts:k(I(w(I(p({executable:Te(),owner:S(),lamports:d(),data:w(S()),rentEpoch:k(d())}))))),unitsConsumed:k(d()),returnData:k(I(p({programId:S(),data:Kn([S(),j("base64")])}))),innerInstructions:k(I(w(p({index:d(),instructions:w(re([Wf,$f]))}))))})),cp=Le(p({byIdentity:Vr(S(),w(d())),range:p({firstSlot:d(),lastSlot:d()})}));var up=G(xf),dp=G(Df),lp=G(Pf),fp=G(Uf),hp=G(zf),_p=G(Mf),pp=G(d()),gp=Le(p({total:d(),circulating:d(),nonCirculating:d(),nonCirculatingAccounts:w(J)})),Vf=p({amount:S(),uiAmount:I(d()),decimals:d(),uiAmountString:k(S())}),yp=Le(w(p({address:J,amount:S(),uiAmount:I(d()),decimals:d(),uiAmountString:k(S())}))),mp=Le(w(p({pubkey:J,account:p({executable:Te(),owner:J,lamports:d(),data:bs,rentEpoch:d()})}))),_s=p({program:S(),parsed:ct(),space:d()}),Rp=Le(w(p({pubkey:J,account:p({executable:Te(),owner:J,lamports:d(),data:_s,rentEpoch:d()})}))),Sp=Le(w(p({lamports:d(),address:J}))),As=p({executable:Te(),owner:J,lamports:d(),data:bs,rentEpoch:d()}),Ep=p({pubkey:J,account:As}),Gf=Et(re([Fn(L.Buffer),_s]),re([wi,_s]),r=>Array.isArray(r)?St(r,bs):r),qf=p({executable:Te(),owner:J,lamports:d(),data:Gf,rentEpoch:d()}),bp=p({pubkey:J,account:qf}),Ap=p({state:re([j("active"),j("inactive"),j("activating"),j("deactivating")]),active:d(),inactive:d()}),wp=G(w(p({signature:S(),slot:d(),err:dt,memo:I(S()),blockTime:k(I(d()))}))),Ip=G(w(p({signature:S(),slot:d(),err:dt,memo:I(S()),blockTime:k(I(d()))}))),Op=p({subscription:d(),result:nr(As)}),Hf=p({pubkey:J,account:As}),Np=p({subscription:d(),result:nr(Hf)}),jf=p({parent:d(),slot:d(),root:d()}),kp=p({subscription:d(),result:jf}),Yf=re([p({type:re([j("firstShredReceived"),j("completed"),j("optimisticConfirmation"),j("root")]),slot:d(),timestamp:d()}),p({type:j("createdBank"),parent:d(),slot:d(),timestamp:d()}),p({type:j("frozen"),slot:d(),timestamp:d(),stats:p({numTransactionEntries:d(),numSuccessfulTransactions:d(),numFailedTransactions:d(),maxTransactionsPerEntry:d()})}),p({type:j("dead"),slot:d(),timestamp:d(),err:S()})]),Tp=p({subscription:d(),result:Yf}),Lp=p({subscription:d(),result:nr(re([Ff,Kf]))}),vp=p({subscription:d(),result:d()}),Cp=p({pubkey:S(),gossip:I(S()),tpu:I(S()),rpc:I(S()),version:I(S())}),fi=p({votePubkey:S(),nodePubkey:S(),activatedStake:d(),epochVoteAccount:Te(),epochCredits:w(Kn([d(),d(),d()])),commission:d(),lastVote:d(),rootSlot:I(d())}),Bp=G(p({current:w(fi),delinquent:w(fi)})),Xf=re([j("processed"),j("confirmed"),j("finalized")]),Jf=p({slot:d(),confirmations:I(d()),err:dt,confirmationStatus:k(Xf)}),xp=Le(w(I(Jf))),Pp=G(d()),Oi=p({accountKey:J,writableIndexes:w(d()),readonlyIndexes:w(d())}),ws=p({signatures:w(S()),message:p({accountKeys:w(S()),header:p({numRequiredSignatures:d(),numReadonlySignedAccounts:d(),numReadonlyUnsignedAccounts:d()}),instructions:w(p({accounts:w(d()),data:S(),programIdIndex:d()})),recentBlockhash:S(),addressTableLookups:k(w(Oi))})}),Ni=p({pubkey:J,signer:Te(),writable:Te(),source:k(re([j("transaction"),j("lookupTable")]))}),ki=p({accountKeys:w(Ni),signatures:w(S())}),Ti=p({parsed:ct(),program:S(),programId:J}),Li=p({accounts:w(J),data:S(),programId:J}),Zf=re([Li,Ti]),Qf=re([p({parsed:ct(),program:S(),programId:S()}),p({accounts:w(S()),data:S(),programId:S()})]),vi=Et(Zf,Qf,r=>"accounts"in r?St(r,Li):St(r,Ti)),Ci=p({signatures:w(S()),message:p({accountKeys:w(Ni),instructions:w(vi),recentBlockhash:S(),addressTableLookups:k(I(w(Oi)))})}),Qn=p({accountIndex:d(),mint:S(),owner:k(S()),programId:k(S()),uiTokenAmount:Vf}),Bi=p({writable:w(J),readonly:w(J)}),rr=p({err:dt,fee:d(),innerInstructions:k(I(w(p({index:d(),instructions:w(p({accounts:w(d()),data:S(),programIdIndex:d()}))})))),preBalances:w(d()),postBalances:w(d()),logMessages:k(I(w(S()))),preTokenBalances:k(I(w(Qn))),postTokenBalances:k(I(w(Qn))),loadedAddresses:k(Bi),computeUnitsConsumed:k(d()),costUnits:k(d())}),Is=p({err:dt,fee:d(),innerInstructions:k(I(w(p({index:d(),instructions:w(vi)})))),preBalances:w(d()),postBalances:w(d()),logMessages:k(I(w(S()))),preTokenBalances:k(I(w(Qn))),postTokenBalances:k(I(w(Qn))),loadedAddresses:k(Bi),computeUnitsConsumed:k(d()),costUnits:k(d())}),Ot=re([j(0),j("legacy")]),lt=p({pubkey:S(),lamports:d(),postBalance:I(d()),rewardType:I(S()),commission:k(I(d()))}),Dp=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),transactions:w(p({transaction:ws,meta:I(rr),version:k(Ot)})),rewards:k(w(lt)),blockTime:I(d()),blockHeight:I(d())}))),Up=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),rewards:k(w(lt)),blockTime:I(d()),blockHeight:I(d())}))),zp=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),transactions:w(p({transaction:ki,meta:I(rr),version:k(Ot)})),rewards:k(w(lt)),blockTime:I(d()),blockHeight:I(d())}))),Mp=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),transactions:w(p({transaction:Ci,meta:I(Is),version:k(Ot)})),rewards:k(w(lt)),blockTime:I(d()),blockHeight:I(d())}))),Fp=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),transactions:w(p({transaction:ki,meta:I(Is),version:k(Ot)})),rewards:k(w(lt)),blockTime:I(d()),blockHeight:I(d())}))),Kp=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),rewards:k(w(lt)),blockTime:I(d()),blockHeight:I(d())}))),Wp=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),transactions:w(p({transaction:ws,meta:I(rr)})),rewards:k(w(lt)),blockTime:I(d())}))),$p=G(I(p({blockhash:S(),previousBlockhash:S(),parentSlot:d(),signatures:w(S()),blockTime:I(d())}))),Vp=G(I(p({slot:d(),meta:I(rr),blockTime:k(I(d())),transaction:ws,version:k(Ot)}))),Gp=G(I(p({slot:d(),transaction:Ci,meta:I(Is),blockTime:k(I(d())),version:k(Ot)}))),qp=Le(p({blockhash:S(),lastValidBlockHeight:d()})),Hp=Le(Te()),eh=p({slot:d(),numTransactions:d(),numSlots:d(),samplePeriodSecs:d()}),jp=G(w(eh)),Yp=Le(I(p({feeCalculator:p({lamportsPerSignature:d()})}))),Xp=G(S()),Jp=G(S()),th=p({err:dt,logs:w(S()),signature:S()}),Zp=p({result:nr(th),subscription:d()});var ps=class r{constructor(e){this._keypair=void 0,this._keypair=e??ai()}static generate(){return new r(ai())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");let n=e.slice(32,64);if(!t||!t.skipValidation){let s=e.slice(0,32),o=is(s);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new r({publicKey:n,secretKey:e})}static fromSeed(e){let t=is(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new r({publicKey:t,secretKey:n})}get publicKey(){return new C(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}},Ht=Object.freeze({CreateLookupTable:{index:0,layout:c.struct([c.u32("instruction"),wt("recentSlot"),c.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:c.struct([c.u32("instruction")])},ExtendLookupTable:{index:2,layout:c.struct([c.u32("instruction"),wt(),c.seq(B(),c.offset(c.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:c.struct([c.u32("instruction")])},CloseLookupTable:{index:4,layout:c.struct([c.u32("instruction")])}});var gs=class{constructor(){}static createLookupTable(e){let[t,n]=C.findProgramAddressSync([e.authority.toBuffer(),Kr().encode(e.recentSlot)],this.programId),s=Ht.CreateLookupTable,o=P(s,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:_e.programId,isSigner:!1,isWritable:!1}];return[new V({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){let t=Ht.FreezeLookupTable,n=P(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new V({programId:this.programId,keys:s,data:n})}static extendLookupTable(e){let t=Ht.ExtendLookupTable,n=P(t,{addresses:e.addresses.map(o=>o.toBytes())}),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&s.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:_e.programId,isSigner:!1,isWritable:!1}),new V({programId:this.programId,keys:s,data:n})}static deactivateLookupTable(e){let t=Ht.DeactivateLookupTable,n=P(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new V({programId:this.programId,keys:s,data:n})}static closeLookupTable(e){let t=Ht.CloseLookupTable,n=P(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new V({programId:this.programId,keys:s,data:n})}};gs.programId=new C("AddressLookupTab1e1111111111111111111111111");var jn=Object.freeze({RequestUnits:{index:0,layout:c.struct([c.u8("instruction"),c.u32("units"),c.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:c.struct([c.u8("instruction"),c.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:c.struct([c.u8("instruction"),c.u32("units")])},SetComputeUnitPrice:{index:3,layout:c.struct([c.u8("instruction"),wt("microLamports")])}}),ys=class{constructor(){}static requestUnits(e){let t=jn.RequestUnits,n=P(t,e);return new V({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){let t=jn.RequestHeapFrame,n=P(t,e);return new V({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){let t=jn.SetComputeUnitLimit,n=P(t,e);return new V({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){let t=jn.SetComputeUnitPrice,n=P(t,{microLamports:BigInt(e.microLamports)});return new V({keys:[],programId:this.programId,data:n})}};ys.programId=new C("ComputeBudget111111111111111111111111111111");var hi=64,_i=32,pi=64,gi=c.struct([c.u8("numSignatures"),c.u8("padding"),c.u16("signatureOffset"),c.u16("signatureInstructionIndex"),c.u16("publicKeyOffset"),c.u16("publicKeyInstructionIndex"),c.u16("messageDataOffset"),c.u16("messageDataSize"),c.u16("messageInstructionIndex")]),ms=class r{constructor(){}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:s,instructionIndex:o}=e;q(t.length===_i,`Public Key must be ${_i} bytes but received ${t.length} bytes`),q(s.length===pi,`Signature must be ${pi} bytes but received ${s.length} bytes`);let i=gi.span,u=i+t.length,a=u+s.length,f=1,h=L.Buffer.alloc(a+n.length),g=o??65535;return gi.encode({numSignatures:f,padding:0,signatureOffset:u,signatureInstructionIndex:g,publicKeyOffset:i,publicKeyInstructionIndex:g,messageDataOffset:a,messageDataSize:n.length,messageInstructionIndex:g},h),h.fill(t,i),h.fill(s,u),h.fill(n,a),new V({keys:[],programId:r.programId,data:h})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:s}=e;q(t.length===hi,`Private key must be ${hi} bytes but received ${t.length} bytes`);try{let o=ps.fromSecretKey(t),i=o.publicKey.toBytes(),u=Ss(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:u,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};ms.programId=new C("Ed25519SigVerify111111111111111111111111111");var nh=(r,e)=>{let t=sn.sign(r,e);return[t.toCompactRawBytes(),t.recovery]};sn.utils.isValidPrivateKey;var rh=sn.getPublicKey,yi=32,rs=20,mi=64,sh=11,ss=c.struct([c.u8("numSignatures"),c.u16("signatureOffset"),c.u8("signatureInstructionIndex"),c.u16("ethAddressOffset"),c.u8("ethAddressInstructionIndex"),c.u16("messageDataOffset"),c.u16("messageDataSize"),c.u8("messageInstructionIndex"),c.blob(20,"ethAddress"),c.blob(64,"signature"),c.u8("recoveryId")]),Rs=class r{constructor(){}static publicKeyToEthAddress(e){q(e.length===mi,`Public key must be ${mi} bytes but received ${e.length} bytes`);try{return L.Buffer.from(dr(U(e))).slice(-rs)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:s,recoveryId:o,instructionIndex:i}=e;return r.createInstructionWithEthAddress({ethAddress:r.publicKeyToEthAddress(t),message:n,signature:s,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){let{ethAddress:t,message:n,signature:s,recoveryId:o,instructionIndex:i=0}=e,u;typeof t=="string"?t.startsWith("0x")?u=L.Buffer.from(t.substr(2),"hex"):u=L.Buffer.from(t,"hex"):u=t,q(u.length===rs,`Address must be ${rs} bytes but received ${u.length} bytes`);let a=1+sh,f=a,h=a+u.length,g=h+s.length+1,A=1,y=L.Buffer.alloc(ss.span+n.length);return ss.encode({numSignatures:A,signatureOffset:h,signatureInstructionIndex:i,ethAddressOffset:f,ethAddressInstructionIndex:i,messageDataOffset:g,messageDataSize:n.length,messageInstructionIndex:i,signature:U(s),ethAddress:U(u),recoveryId:o},y),y.fill(U(n),ss.span),new V({keys:[],programId:r.programId,data:y})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:s}=e;q(t.length===yi,`Private key must be ${yi} bytes but received ${t.length} bytes`);try{let o=U(t),i=rh(o,!1).slice(1),u=L.Buffer.from(dr(U(n))),[a,f]=nh(u,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,recoveryId:f,instructionIndex:s})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};Rs.programId=new C("KeccakSecp256k11111111111111111111111111111");var xi,oh=new C("StakeConfig11111111111111111111111111111111");var Jt=class{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}};xi=Jt;Jt.default=new xi(0,0,C.default);var nt=Object.freeze({Initialize:{index:0,layout:c.struct([c.u32("instruction"),Sf(),Ef()])},Authorize:{index:1,layout:c.struct([c.u32("instruction"),B("newAuthorized"),c.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:c.struct([c.u32("instruction")])},Split:{index:3,layout:c.struct([c.u32("instruction"),c.ns64("lamports")])},Withdraw:{index:4,layout:c.struct([c.u32("instruction"),c.ns64("lamports")])},Deactivate:{index:5,layout:c.struct([c.u32("instruction")])},Merge:{index:7,layout:c.struct([c.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:c.struct([c.u32("instruction"),B("newAuthorized"),c.u32("stakeAuthorizationType"),bt("authoritySeed"),B("authorityOwner")])}}),Qp=Object.freeze({Staker:{index:0},Withdrawer:{index:1}}),er=class{constructor(){}static initialize(e){let{stakePubkey:t,authorized:n,lockup:s}=e,o=s||Jt.default,i=nt.Initialize,u=P(i,{authorized:{staker:U(n.staker.toBuffer()),withdrawer:U(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:U(o.custodian.toBuffer())}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1}],programId:this.programId,data:u};return new V(a)}static createAccountWithSeed(e){let t=new Y;t.add(_e.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static createAccount(e){let t=new Y;t.add(_e.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:s,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:s,lockup:o}))}static delegate(e){let{stakePubkey:t,authorizedPubkey:n,votePubkey:s}=e,o=nt.Delegate,i=P(o);return new Y().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:ns,isSigner:!1,isWritable:!1},{pubkey:oh,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){let{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:i}=e,u=nt.Authorize,a=P(u,{newAuthorized:U(s.toBuffer()),stakeAuthorizationType:o.index}),f=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&f.push({pubkey:i,isSigner:!0,isWritable:!1}),new Y().add({keys:f,programId:this.programId,data:a})}static authorizeWithSeed(e){let{stakePubkey:t,authorityBase:n,authoritySeed:s,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:u,custodianPubkey:a}=e,f=nt.AuthorizeWithSeed,h=P(f,{newAuthorized:U(i.toBuffer()),stakeAuthorizationType:u.index,authoritySeed:s,authorityOwner:U(o.toBuffer())}),g=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}];return a&&g.push({pubkey:a,isSigner:!0,isWritable:!1}),new Y().add({keys:g,programId:this.programId,data:h})}static splitInstruction(e){let{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:s,lamports:o}=e,i=nt.Split,u=P(i,{lamports:o});return new V({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:u})}static split(e,t){let n=new Y;return n.add(_e.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){let{stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,basePubkey:i,seed:u,lamports:a}=e,f=new Y;return f.add(_e.allocate({accountPubkey:o,basePubkey:i,seed:u,space:this.space,programId:this.programId})),t&&t>0&&f.add(_e.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),f.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:s,splitStakePubkey:o,lamports:a}))}static merge(e){let{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:s}=e,o=nt.Merge,i=P(o);return new Y().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:ns,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){let{stakePubkey:t,authorizedPubkey:n,toPubkey:s,lamports:o,custodianPubkey:i}=e,u=nt.Withdraw,a=P(u,{lamports:o}),f=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:ns,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&f.push({pubkey:i,isSigner:!0,isWritable:!1}),new Y().add({keys:f,programId:this.programId,data:a})}static deactivate(e){let{stakePubkey:t,authorizedPubkey:n}=e,s=nt.Deactivate,o=P(s);return new Y().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}};er.programId=new C("Stake11111111111111111111111111111111111111");er.space=200;var jt=Object.freeze({InitializeAccount:{index:0,layout:c.struct([c.u32("instruction"),bf()])},Authorize:{index:1,layout:c.struct([c.u32("instruction"),B("newAuthorized"),c.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:c.struct([c.u32("instruction"),c.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:c.struct([c.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:c.struct([c.u32("instruction"),Af()])}}),eg=Object.freeze({Voter:{index:0},Withdrawer:{index:1}}),tr=class r{constructor(){}static initializeAccount(e){let{votePubkey:t,nodePubkey:n,voteInit:s}=e,o=jt.InitializeAccount,i=P(o,{voteInit:{nodePubkey:U(s.nodePubkey.toBuffer()),authorizedVoter:U(s.authorizedVoter.toBuffer()),authorizedWithdrawer:U(s.authorizedWithdrawer.toBuffer()),commission:s.commission}}),u={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new V(u)}static createAccount(e){let t=new Y;return t.add(_e.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){let{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:s,voteAuthorizationType:o}=e,i=jt.Authorize,u=P(i,{newAuthorized:U(s.toBuffer()),voteAuthorizationType:o.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new Y().add({keys:a,programId:this.programId,data:u})}static authorizeWithSeed(e){let{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:s,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:u}=e,a=jt.AuthorizeWithSeed,f=P(a,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:U(n.toBuffer()),currentAuthorityDerivedKeySeed:s,newAuthorized:U(o.toBuffer()),voteAuthorizationType:i.index}}),h=[{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new Y().add({keys:h,programId:this.programId,data:f})}static withdraw(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:s,toPubkey:o}=e,i=jt.Withdraw,u=P(i,{lamports:s}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new Y().add({keys:a,programId:this.programId,data:u})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return r.withdraw(e)}static updateValidatorIdentity(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:s}=e,o=jt.UpdateValidatorIdentity,i=P(o),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new Y().add({keys:u,programId:this.programId,data:i})}};tr.programId=new C("Vote111111111111111111111111111111111111111");tr.space=3762;var tg=new C("Va1idator1nfo111111111111111111111111111111"),ng=p({name:S(),website:k(S()),details:k(S()),iconUrl:k(S()),keybaseUsername:k(S())});var rg=new C("Vote111111111111111111111111111111111111111"),sg=c.struct([B("nodePubkey"),B("authorizedWithdrawer"),c.u8("commission"),c.nu64(),c.seq(c.struct([c.nu64("slot"),c.u32("confirmationCount")]),c.offset(c.u32(),-8),"votes"),c.u8("rootSlotValid"),c.nu64("rootSlot"),c.nu64(),c.seq(c.struct([c.nu64("epoch"),B("authorizedVoter")]),c.offset(c.u32(),-8),"authorizedVoters"),c.struct([c.seq(c.struct([B("authorizedPubkey"),c.nu64("epochOfLastAuthorizedSwitch"),c.nu64("targetEpoch")]),32,"buf"),c.nu64("idx"),c.u8("isEmpty")],"priorVoters"),c.nu64(),c.seq(c.struct([c.nu64("epoch"),c.nu64("credits"),c.nu64("prevCredits")]),c.offset(c.u32(),-8),"epochCredits"),c.struct([c.nu64("slot"),c.nu64("timestamp")],"lastTimestamp")]);var sr=class extends Fs{constructor({config:e,state:t}){super({config:e,state:t})}async switchChain(e){throw pe.unsupportedOperation("Chain switching is not supported by this connector")}async setupProvider(e,t){let n=new Bs,s=this.getChain(t),o=this.getProviderHandlers(e),i=Zs(o);n.push(i);let u=Js(s);n.push(u);let a=this.getInjectedProviderProxy(e);a&&n.push(a);let f=xs(n);this.updateProviderEngineProxy(f),await this.lookupNetwork(e,t)}async lookupNetwork(e,t){return this.update({chainId:t}),t||""}getInjectedProviderProxy(e){}};var Pi=r=>({requestAccounts:async()=>r.publicKey?[He.encode(r.publicKey.toBytes())]:[],getPublicKey:async()=>r.publicKey?He.encode(r.publicKey.toBytes()):"",getAccounts:async()=>r.publicKey?[He.encode(r.publicKey.toBytes())]:[],getPrivateKey:async()=>{throw en.methodNotSupported()},getSecretKey:async()=>{throw en.methodNotSupported()},signTransaction:async t=>await r.signTransaction(t.params.message),signMessage:async t=>await r.signMessage(t.params.data,t.params.from,t.params.display),signAllTransactions:async t=>{var n,s;if(!((n=t.params)!==null&&n!==void 0&&n.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw en.invalidParams("message");return await r.signAllTransactions(t.params.message)},signAndSendTransaction:async t=>await r.signAndSendTransaction(t.params.message)});var or=r=>{switch(r.chainId){case"0x65":return"solana:mainnet";case"0x66":return"solana:testnet";case"0x67":return"solana:devnet";default:return null}};var ir=class extends sr{getProviderHandlers(e){let t=or(this.config.chain),n=()=>{let a=e?.accounts[0];if(!a)throw pe.notConnectedError();return a};return Pi({get publicKey(){return new C(n().publicKey)},signMessage:async a=>{let f=n(),h=new Uint8Array(Buffer.from(a,"utf-8")),g=await e.features[an].signMessage({account:f,message:h});return He.encode(g[0].signature)},signTransaction:async a=>{let f=n(),h=await e.features[vt].signTransaction({account:f,transaction:new Uint8Array(Buffer.from(a,"base64")),chain:t});return He.encode(Zn.deserialize(h[0].signedTransaction).signatures[0])},signAllTransactions:async a=>{let f=n();return Promise.all(a.map(async h=>{let g=await e.features[vt].signTransaction({account:f,transaction:new Uint8Array(Buffer.from(h,"base64")),chain:t});return Buffer.from(g[0].signedTransaction).toString("base64")}))},signAndSendTransaction:async a=>{let f=n(),h=await e.features[on].signAndSendTransaction({account:f,transaction:new Uint8Array(Buffer.from(a,"base64")),chain:t});return He.encode(h[0].signature)}})}};var Os=class extends ln{constructor(e){super(e),Pe(this,"name",void 0),Pe(this,"connectorNamespace",Ks.SOLANA),Pe(this,"currentChainNamespace",Ps.SOLANA),Pe(this,"type",Ws.EXTERNAL),Pe(this,"isInjected",!0),Pe(this,"status",Ae.NOT_READY),Pe(this,"wallet",null),Pe(this,"injectedProvider",null),this.name=e.name,this.icon=e.wallet.icon,this.wallet=["gate","solflare"].includes(this.name)?Object.freeze(e.wallet):e.wallet}get provider(){return this.status!==Ae.NOT_READY&&this.injectedProvider?this.injectedProvider:null}get isWalletConnected(){return this.status===Ae.CONNECTED&&this.wallet.accounts.length>0}async init(e){await super.init(e);let t=this.coreOptions.chains.find(n=>n.chainId===e.chainId);super.checkInitializationRequirements({chainConfig:t}),this.injectedProvider=new ir({config:{chain:t,chains:this.coreOptions.chains}}),await this.injectedProvider.setupProvider(this.wallet,e.chainId),this.status=Ae.READY,this.emit(De.READY,this.name);try{if(zs.debug("initializing solana injected connector"),e.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:e.chainId})))throw this.rehydrated=!1,pe.connectionError("Failed to rehydrate.")}catch(n){this.emit(De.REHYDRATION_ERROR,n)}}async connect({chainId:e}){try{super.checkConnectionRequirements();let t=this.coreOptions.chains.find(s=>s.chainId===e);if(!t)throw pe.connectionError("Chain config is not available");this.status=Ae.CONNECTING,this.emit(De.CONNECTING,{connector:this.name});let n=or(t);if(!this.wallet.chains.find(s=>s===n))throw pe.connectionError(`Chain ${n} not supported. Supported chains are ${this.wallet.chains.join(", ")}`);if(this.isWalletConnected||await this.wallet.features[dn].connect(),this.wallet.accounts.length===0)throw pe.connectionError();return this.status=Ae.CONNECTED,this.emit(De.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.provider}),this.provider}catch(t){throw this.status=Ae.READY,this.rehydrated||this.emit(De.ERRORED,t),this.rehydrated=!1,t}}async disconnect(e={cleanup:!1}){await super.disconnectSession();try{var t;await((t=this.wallet.features[to])===null||t===void 0?void 0:t.disconnect()),e.cleanup?(this.status=Ae.NOT_READY,this.injectedProvider=null):this.status=Ae.READY,await super.disconnect()}catch(n){this.emit(De.ERRORED,pe.disconnectionError(n?.message))}}async getUserInfo(){if(!this.isWalletConnected)throw pe.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async switchChain(e,t=!1){var n;super.checkSwitchChainRequirements(e,t),await((n=this.injectedProvider)===null||n===void 0?void 0:n.switchChain(e))}async enableMFA(){throw new Error("Method not implemented.")}async manageMFA(){throw new Error("Method Not implemented")}},ih=r=>({coreOptions:e})=>new Os({name:Ms(r.name),wallet:r,coreOptions:e});var zg=r=>{let{chains:e,features:t}=r;return e.some(o=>o.startsWith("solana"))?!![dn,an,vt,on].every(o=>Object.keys(t).includes(o)):void 0};export{Qe as a,Vo as b,Qr as c,Wi as d,ih as e,zg as f};
