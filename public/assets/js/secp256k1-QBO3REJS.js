import{a as vt,c as me}from"./chunk-4H2HG446.js";import{b as de,p as he,s as Tt}from"./chunk-E62CRSR5.js";import"./chunk-BG6P72OF.js";var Kt=BigInt(0),jt=BigInt(1);function wt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function F(t){if(!wt(t))throw new Error("Uint8Array expected")}function gt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function Bt(t){let n=t.toString(16);return n.length&1?"0"+n:n}function pe(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Kt:BigInt("0x"+t)}var ye=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ge=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function pt(t){if(F(t),ye)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Ge[t[e]];return n}var $={_0:48,_9:57,A:65,F:70,a:97,f:102};function we(t){if(t>=$._0&&t<=$._9)return t-$._0;if(t>=$.A&&t<=$.F)return t-($.A-10);if(t>=$.a&&t<=$.f)return t-($.a-10)}function St(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(ye)return Uint8Array.fromHex(t);let n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);let r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){let c=we(t.charCodeAt(i)),f=we(t.charCodeAt(i+1));if(c===void 0||f===void 0){let o=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+i)}r[s]=c*16+f}return r}function D(t){return pe(pt(t))}function Yt(t){return F(t),pe(pt(Uint8Array.from(t).reverse()))}function Q(t,n){return St(t.toString(16).padStart(n*2,"0"))}function Dt(t,n){return Q(t,n).reverse()}function V(t,n,e){let r;if(typeof n=="string")try{r=St(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(wt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");let s=r.length;if(typeof e=="number"&&s!==e)throw new Error(t+" of length "+e+" expected, got "+s);return r}function j(...t){let n=0;for(let r=0;r<t.length;r++){let s=t[r];F(s),n+=s.length}let e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){let i=t[r];e.set(i,s),s+=i.length}return e}function Rt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}var Ht=t=>typeof t=="bigint"&&Kt<=t;function at(t,n,e){return Ht(t)&&Ht(n)&&Ht(e)&&n<=t&&t<e}function tt(t,n,e,r){if(!at(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function be(t){let n;for(n=0;t>Kt;t>>=jt,n+=1);return n}var ut=t=>(jt<<BigInt(t))-jt,Pt=t=>new Uint8Array(t),ge=t=>Uint8Array.from(t);function xe(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Pt(t),s=Pt(t),i=0,c=()=>{r.fill(1),s.fill(0),i=0},f=(...g)=>e(s,r,...g),o=(g=Pt(0))=>{s=f(ge([0]),g),r=f(),g.length!==0&&(s=f(ge([1]),g),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let g=0,x=[];for(;g<n;){r=f();let E=r.slice();x.push(E),g+=r.length}return j(...x)};return(g,x)=>{c(),o(g);let E;for(;!(E=x(u()));)o();return c(),E}}var Xe={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||wt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function et(t,n,e={}){let r=(s,i,c)=>{let f=Xe[i];if(typeof f!="function")throw new Error("invalid validator function");let o=t[s];if(!(c&&o===void 0)&&!f(o,t))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+o)};for(let[s,i]of Object.entries(n))r(s,i,!1);for(let[s,i]of Object.entries(e))r(s,i,!0);return t}function Wt(t){let n=new WeakMap;return(e,...r)=>{let s=n.get(e);if(s!==void 0)return s;let i=t(e,...r);return n.set(e,i),i}}var K=BigInt(0),H=BigInt(1),lt=BigInt(2),Qe=BigInt(3),ve=BigInt(4),Be=BigInt(5),Se=BigInt(8);function M(t,n){let e=t%n;return e>=K?e:n+e}function W(t,n,e){let r=t;for(;n-- >K;)r*=r,r%=e;return r}function Ut(t,n){if(t===K)throw new Error("invert: expected non-zero number");if(n<=K)throw new Error("invert: expected positive modulus, got "+n);let e=M(t,n),r=n,s=K,i=H,c=H,f=K;for(;e!==K;){let u=r/e,d=r%e,g=s-c*u,x=i-f*u;r=e,e=d,s=c,i=f,c=g,f=x}if(r!==H)throw new Error("invert: does not exist");return M(s,n)}function Ae(t,n){let e=(t.ORDER+H)/ve,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function Je(t,n){let e=(t.ORDER-Be)/Se,r=t.mul(n,lt),s=t.pow(r,e),i=t.mul(n,s),c=t.mul(t.mul(i,lt),s),f=t.mul(i,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}function $e(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-H,e=0;for(;n%lt===K;)n/=lt,e++;let r=lt,s=At(t);for(;Ee(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Ae;let i=s.pow(r,n),c=(n+H)/lt;return function(o,u){if(o.is0(u))return u;if(Ee(o,u)!==1)throw new Error("Cannot find square root");let d=e,g=o.mul(o.ONE,i),x=o.pow(u,n),E=o.pow(u,c);for(;!o.eql(x,o.ONE);){if(o.is0(x))return o.ZERO;let N=1,w=o.sqr(x);for(;!o.eql(w,o.ONE);)if(N++,w=o.sqr(w),N===d)throw new Error("Cannot find square root");let L=H<<BigInt(d-N-1),O=o.pow(g,L);d=N,g=o.sqr(O),x=o.mul(x,g),E=o.mul(E,O)}return E}}function Fe(t){return t%ve===Qe?Ae:t%Se===Be?Je:$e(t)}var tn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Zt(t){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=tn.reduce((r,s)=>(r[s]="function",r),n);return et(t,e)}function en(t,n,e){if(e<K)throw new Error("invalid exponent, negatives unsupported");if(e===K)return t.ONE;if(e===H)return n;let r=t.ONE,s=n;for(;e>K;)e&H&&(r=t.mul(r,s)),s=t.sqr(s),e>>=H;return r}function yt(t,n,e=!1){let r=new Array(n.length).fill(e?t.ZERO:void 0),s=n.reduce((c,f,o)=>t.is0(f)?c:(r[o]=c,t.mul(c,f)),t.ONE),i=t.inv(s);return n.reduceRight((c,f,o)=>t.is0(f)?c:(r[o]=t.mul(c,r[o]),t.mul(c,f)),i),r}function Ee(t,n){let e=(t.ORDER-H)/lt,r=t.pow(n,e),s=t.eql(r,t.ONE),i=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!s&&!i&&!c)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Gt(t,n){n!==void 0&&de(n);let e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function At(t,n,e=!1,r={}){if(t<=K)throw new Error("invalid field: expected ORDER > 0, got "+t);let{nBitLength:s,nByteLength:i}=Gt(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c,f=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:i,MASK:ut(s),ZERO:K,ONE:H,create:o=>M(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return K<=o&&o<t},is0:o=>o===K,isOdd:o=>(o&H)===H,neg:o=>M(-o,t),eql:(o,u)=>o===u,sqr:o=>M(o*o,t),add:(o,u)=>M(o+u,t),sub:(o,u)=>M(o-u,t),mul:(o,u)=>M(o*u,t),pow:(o,u)=>en(f,o,u),div:(o,u)=>M(o*Ut(u,t),t),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>Ut(o,t),sqrt:r.sqrt||(o=>(c||(c=Fe(t)),c(f,o))),toBytes:o=>e?Dt(o,i):Q(o,i),fromBytes:o=>{if(o.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+o.length);return e?Yt(o):D(o)},invertBatch:o=>yt(f,o),cmov:(o,u,d)=>d?u:o});return Object.freeze(f)}function Oe(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let n=t.toString(2).length;return Math.ceil(n/8)}function Xt(t){let n=Oe(t);return n+Math.ceil(n/2)}function Ie(t,n,e=!1){let r=t.length,s=Oe(n),i=Xt(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);let c=e?Yt(t):D(t),f=M(c,n-H)+H;return e?Dt(f,s):Q(f,s)}var _e=BigInt(0),te=BigInt(1);function Qt(t,n){let e=n.negate();return t?e:n}function Ne(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Jt(t,n){Ne(t,n);let e=Math.ceil(n/t)+1,r=2**(t-1),s=2**t,i=ut(t),c=BigInt(t);return{windows:e,windowSize:r,mask:i,maxNumber:s,shiftBy:c}}function qe(t,n,e){let{windowSize:r,mask:s,maxNumber:i,shiftBy:c}=e,f=Number(t&s),o=t>>c;f>r&&(f-=i,o+=te);let u=n*r,d=u+Math.abs(f)-1,g=f===0,x=f<0,E=n%2!==0;return{nextN:o,offset:d,isZero:g,isNeg:x,isNegF:E,offsetF:u}}function nn(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function rn(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}var $t=new WeakMap,Te=new WeakMap;function Ft(t){return Te.get(t)||1}function Re(t,n){return{constTimeNegate:Qt,hasPrecomputes(e){return Ft(e)!==1},unsafeLadder(e,r,s=t.ZERO){let i=e;for(;r>_e;)r&te&&(s=s.add(i)),i=i.double(),r>>=te;return s},precomputeWindow(e,r){let{windows:s,windowSize:i}=Jt(r,n),c=[],f=e,o=f;for(let u=0;u<s;u++){o=f,c.push(o);for(let d=1;d<i;d++)o=o.add(f),c.push(o);f=o.double()}return c},wNAF(e,r,s){let i=t.ZERO,c=t.BASE,f=Jt(e,n);for(let o=0;o<f.windows;o++){let{nextN:u,offset:d,isZero:g,isNeg:x,isNegF:E,offsetF:N}=qe(s,o,f);s=u,g?c=c.add(Qt(E,r[N])):i=i.add(Qt(x,r[d]))}return{p:i,f:c}},wNAFUnsafe(e,r,s,i=t.ZERO){let c=Jt(e,n);for(let f=0;f<c.windows&&s!==_e;f++){let{nextN:o,offset:u,isZero:d,isNeg:g}=qe(s,f,c);if(s=o,!d){let x=r[u];i=i.add(g?x.negate():x)}}return i},getPrecomputes(e,r,s){let i=$t.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&$t.set(r,s(i))),i},wNAFCached(e,r,s){let i=Ft(e);return this.wNAF(i,this.getPrecomputes(i,e,s),r)},wNAFCachedUnsafe(e,r,s,i){let c=Ft(e);return c===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,s),r,i)},setWindowSize(e,r){Ne(r,n),Te.set(e,r),$t.delete(e)}}}function Ue(t,n,e,r){nn(e,t),rn(r,n);let s=e.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");let c=t.ZERO,f=be(BigInt(s)),o=1;f>12?o=f-3:f>4?o=f-2:f>0&&(o=2);let u=ut(o),d=new Array(Number(u)+1).fill(c),g=Math.floor((n.BITS-1)/o)*o,x=c;for(let E=g;E>=0;E-=o){d.fill(c);for(let w=0;w<i;w++){let L=r[w],O=Number(L>>BigInt(E)&u);d[O]=d[O].add(e[w])}let N=c;for(let w=d.length-1,L=c;w>0;w--)L=L.add(d[w]),N=N.add(L);if(x=x.add(N),E!==0)for(let w=0;w<o;w++)x=x.double()}return x}function ee(t){return Zt(t.Fp),et(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Gt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Ze(t){t.lowS!==void 0&&gt("lowS",t.lowS),t.prehash!==void 0&&gt("prehash",t.prehash)}function on(t){let n=ee(t);et(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});let{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}var re=class extends Error{constructor(n=""){super(n)}},nt={Err:re,_tlv:{encode:(t,n)=>{let{Err:e}=nt;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");let r=n.length/2,s=Bt(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");let i=r>127?Bt(s.length/2|128):"";return Bt(t)+i+s+n},decode(t,n){let{Err:e}=nt,r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");let s=n[r++],i=!!(s&128),c=0;if(!i)c=s;else{let o=s&127;if(!o)throw new e("tlv.decode(long): indefinite length not supported");if(o>4)throw new e("tlv.decode(long): byte length is too big");let u=n.subarray(r,r+o);if(u.length!==o)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(let d of u)c=c<<8|d;if(r+=o,c<128)throw new e("tlv.decode(long): not minimal encoding")}let f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){let{Err:n}=nt;if(t<X)throw new n("integer: negative integers are not allowed");let e=Bt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){let{Err:n}=nt;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return D(t)}},toSig(t){let{Err:n,_int:e,_tlv:r}=nt,s=V("signature",t),{v:i,l:c}=r.decode(48,s);if(c.length)throw new n("invalid signature: left bytes after parsing");let{v:f,l:o}=r.decode(2,i),{v:u,l:d}=r.decode(2,o);if(d.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){let{_tlv:n,_int:e}=nt,r=n.encode(2,e.encode(t.r)),s=n.encode(2,e.encode(t.s)),i=r+s;return n.encode(48,i)}};function ne(t,n){return pt(Q(t,n))}var X=BigInt(0),k=BigInt(1),ot=BigInt(2),Ot=BigInt(3),oe=BigInt(4);function sn(t){let n=on(t),{Fp:e}=n,r=At(n.n,n.nBitLength),s=n.toBytes||((p,a,m)=>{let y=a.toAffine();return j(Uint8Array.from([4]),e.toBytes(y.x),e.toBytes(y.y))}),i=n.fromBytes||(p=>{let a=p.subarray(1),m=e.fromBytes(a.subarray(0,e.BYTES)),y=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:m,y}});function c(p){let{a,b:m}=n,y=e.sqr(p),v=e.mul(y,p);return e.add(e.add(v,e.mul(p,a)),m)}function f(p,a){let m=e.sqr(a),y=c(p);return e.eql(m,y)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");let o=e.mul(e.pow(n.a,Ot),oe),u=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(o,u)))throw new Error("bad curve params: a or b");function d(p){return at(p,k,n.n)}function g(p){let{allowedPrivateKeyLengths:a,nByteLength:m,wrapPrivateKey:y,n:v}=n;if(a&&typeof p!="bigint"){if(wt(p)&&(p=pt(p)),typeof p!="string"||!a.includes(p.length))throw new Error("invalid private key");p=p.padStart(m*2,"0")}let I;try{I=typeof p=="bigint"?p:D(V("private key",p,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof p)}return y&&(I=M(I,v)),tt("private key",I,k,v),I}function x(p){if(!(p instanceof w))throw new Error("ProjectivePoint expected")}let E=Wt((p,a)=>{let{px:m,py:y,pz:v}=p;if(e.eql(v,e.ONE))return{x:m,y};let I=p.is0();a==null&&(a=I?e.ONE:e.inv(v));let U=e.mul(m,a),Z=e.mul(y,a),B=e.mul(v,a);if(I)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:U,y:Z}}),N=Wt(p=>{if(p.is0()){if(n.allowInfinityPoint&&!e.is0(p.py))return;throw new Error("bad point: ZERO")}let{x:a,y:m}=p.toAffine();if(!e.isValid(a)||!e.isValid(m))throw new Error("bad point: x or y not FE");if(!f(a,m))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(a,m,y){if(a==null||!e.isValid(a))throw new Error("x required");if(m==null||!e.isValid(m)||e.is0(m))throw new Error("y required");if(y==null||!e.isValid(y))throw new Error("z required");this.px=a,this.py=m,this.pz=y,Object.freeze(this)}static fromAffine(a){let{x:m,y}=a||{};if(!a||!e.isValid(m)||!e.isValid(y))throw new Error("invalid affine point");if(a instanceof w)throw new Error("projective point not allowed");let v=I=>e.eql(I,e.ZERO);return v(m)&&v(y)?w.ZERO:new w(m,y,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){let m=yt(e,a.map(y=>y.pz));return a.map((y,v)=>y.toAffine(m[v])).map(w.fromAffine)}static fromHex(a){let m=w.fromAffine(i(V("pointHex",a)));return m.assertValidity(),m}static fromPrivateKey(a){return w.BASE.multiply(g(a))}static msm(a,m){return Ue(w,r,a,m)}_setWindowSize(a){R.setWindowSize(this,a)}assertValidity(){N(this)}hasEvenY(){let{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){x(a);let{px:m,py:y,pz:v}=this,{px:I,py:U,pz:Z}=a,B=e.eql(e.mul(m,Z),e.mul(I,v)),T=e.eql(e.mul(y,Z),e.mul(U,v));return B&&T}negate(){return new w(this.px,e.neg(this.py),this.pz)}double(){let{a,b:m}=n,y=e.mul(m,Ot),{px:v,py:I,pz:U}=this,Z=e.ZERO,B=e.ZERO,T=e.ZERO,S=e.mul(v,v),z=e.mul(I,I),h=e.mul(U,U),l=e.mul(v,I);return l=e.add(l,l),T=e.mul(v,U),T=e.add(T,T),Z=e.mul(a,T),B=e.mul(y,h),B=e.add(Z,B),Z=e.sub(z,B),B=e.add(z,B),B=e.mul(Z,B),Z=e.mul(l,Z),T=e.mul(y,T),h=e.mul(a,h),l=e.sub(S,h),l=e.mul(a,l),l=e.add(l,T),T=e.add(S,S),S=e.add(T,S),S=e.add(S,h),S=e.mul(S,l),B=e.add(B,S),h=e.mul(I,U),h=e.add(h,h),S=e.mul(h,l),Z=e.sub(Z,S),T=e.mul(h,z),T=e.add(T,T),T=e.add(T,T),new w(Z,B,T)}add(a){x(a);let{px:m,py:y,pz:v}=this,{px:I,py:U,pz:Z}=a,B=e.ZERO,T=e.ZERO,S=e.ZERO,z=n.a,h=e.mul(n.b,Ot),l=e.mul(m,I),b=e.mul(y,U),q=e.mul(v,Z),A=e.add(m,y),_=e.add(I,U);A=e.mul(A,_),_=e.add(l,b),A=e.sub(A,_),_=e.add(m,v);let C=e.add(I,Z);return _=e.mul(_,C),C=e.add(l,q),_=e.sub(_,C),C=e.add(y,v),B=e.add(U,Z),C=e.mul(C,B),B=e.add(b,q),C=e.sub(C,B),S=e.mul(z,_),B=e.mul(h,q),S=e.add(B,S),B=e.sub(b,S),S=e.add(b,S),T=e.mul(B,S),b=e.add(l,l),b=e.add(b,l),q=e.mul(z,q),_=e.mul(h,_),b=e.add(b,q),q=e.sub(l,q),q=e.mul(z,q),_=e.add(_,q),l=e.mul(b,_),T=e.add(T,l),l=e.mul(C,_),B=e.mul(A,B),B=e.sub(B,l),l=e.mul(A,b),S=e.mul(C,S),S=e.add(S,l),new w(B,T,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(w.ZERO)}wNAF(a){return R.wNAFCached(this,a,w.normalizeZ)}multiplyUnsafe(a){let{endo:m,n:y}=n;tt("scalar",a,X,y);let v=w.ZERO;if(a===X)return v;if(this.is0()||a===k)return this;if(!m||R.hasPrecomputes(this))return R.wNAFCachedUnsafe(this,a,w.normalizeZ);let{k1neg:I,k1:U,k2neg:Z,k2:B}=m.splitScalar(a),T=v,S=v,z=this;for(;U>X||B>X;)U&k&&(T=T.add(z)),B&k&&(S=S.add(z)),z=z.double(),U>>=k,B>>=k;return I&&(T=T.negate()),Z&&(S=S.negate()),S=new w(e.mul(S.px,m.beta),S.py,S.pz),T.add(S)}multiply(a){let{endo:m,n:y}=n;tt("scalar",a,k,y);let v,I;if(m){let{k1neg:U,k1:Z,k2neg:B,k2:T}=m.splitScalar(a),{p:S,f:z}=this.wNAF(Z),{p:h,f:l}=this.wNAF(T);S=R.constTimeNegate(U,S),h=R.constTimeNegate(B,h),h=new w(e.mul(h.px,m.beta),h.py,h.pz),v=S.add(h),I=z.add(l)}else{let{p:U,f:Z}=this.wNAF(a);v=U,I=Z}return w.normalizeZ([v,I])[0]}multiplyAndAddUnsafe(a,m,y){let v=w.BASE,I=(Z,B)=>B===X||B===k||!Z.equals(v)?Z.multiplyUnsafe(B):Z.multiply(B),U=I(this,m).add(I(a,y));return U.is0()?void 0:U}toAffine(a){return E(this,a)}isTorsionFree(){let{h:a,isTorsionFree:m}=n;if(a===k)return!0;if(m)return m(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:a,clearCofactor:m}=n;return a===k?this:m?m(w,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return gt("isCompressed",a),this.assertValidity(),s(w,this,a)}toHex(a=!0){return gt("isCompressed",a),pt(this.toRawBytes(a))}}w.BASE=new w(n.Gx,n.Gy,e.ONE),w.ZERO=new w(e.ZERO,e.ONE,e.ZERO);let{endo:L,nBitLength:O}=n,R=Re(w,L?Math.ceil(O/2):O);return{CURVE:n,ProjectivePoint:w,normPrivateKeyToScalar:g,weierstrassEquation:c,isWithinCurveOrder:d}}function cn(t){let n=ee(t);return et(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Le(t){let n=cn(t),{Fp:e,n:r,nByteLength:s,nBitLength:i}=n,c=e.BYTES+1,f=2*e.BYTES+1;function o(h){return M(h,r)}function u(h){return Ut(h,r)}let{ProjectivePoint:d,normPrivateKeyToScalar:g,weierstrassEquation:x,isWithinCurveOrder:E}=sn({...n,toBytes(h,l,b){let q=l.toAffine(),A=e.toBytes(q.x),_=j;return gt("isCompressed",b),b?_(Uint8Array.from([l.hasEvenY()?2:3]),A):_(Uint8Array.from([4]),A,e.toBytes(q.y))},fromBytes(h){let l=h.length,b=h[0],q=h.subarray(1);if(l===c&&(b===2||b===3)){let A=D(q);if(!at(A,k,e.ORDER))throw new Error("Point is not on curve");let _=x(A),C;try{C=e.sqrt(_)}catch(G){let Y=G instanceof Error?": "+G.message:"";throw new Error("Point is not on curve"+Y)}let P=(C&k)===k;return(b&1)===1!==P&&(C=e.neg(C)),{x:A,y:C}}else if(l===f&&b===4){let A=e.fromBytes(q.subarray(0,e.BYTES)),_=e.fromBytes(q.subarray(e.BYTES,2*e.BYTES));return{x:A,y:_}}else{let A=c,_=f;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+_+", got "+l)}}});function N(h){let l=r>>k;return h>l}function w(h){return N(h)?o(-h):h}let L=(h,l,b)=>D(h.slice(l,b));class O{constructor(l,b,q){tt("r",l,k,r),tt("s",b,k,r),this.r=l,this.s=b,q!=null&&(this.recovery=q),Object.freeze(this)}static fromCompact(l){let b=s;return l=V("compactSignature",l,b*2),new O(L(l,0,b),L(l,b,2*b))}static fromDER(l){let{r:b,s:q}=nt.toSig(V("DER",l));return new O(b,q)}assertValidity(){}addRecoveryBit(l){return new O(this.r,this.s,l)}recoverPublicKey(l){let{r:b,s:q,recovery:A}=this,_=v(V("msgHash",l));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");let C=A===2||A===3?b+n.n:b;if(C>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let P=(A&1)===0?"02":"03",J=d.fromHex(P+ne(C,e.BYTES)),G=u(C),Y=o(-_*G),dt=o(q*G),rt=d.BASE.multiplyAndAddUnsafe(J,Y,dt);if(!rt)throw new Error("point at infinify");return rt.assertValidity(),rt}hasHighS(){return N(this.s)}normalizeS(){return this.hasHighS()?new O(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return St(this.toDERHex())}toDERHex(){return nt.hexFromSig(this)}toCompactRawBytes(){return St(this.toCompactHex())}toCompactHex(){let l=s;return ne(this.r,l)+ne(this.s,l)}}let R={isValidPrivateKey(h){try{return g(h),!0}catch{return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{let h=Xt(n.n);return Ie(n.randomBytes(h),n.n)},precompute(h=8,l=d.BASE){return l._setWindowSize(h),l.multiply(BigInt(3)),l}};function p(h,l=!0){return d.fromPrivateKey(h).toRawBytes(l)}function a(h){if(typeof h=="bigint")return!1;if(h instanceof d)return!0;let b=V("key",h).length,q=e.BYTES,A=q+1,_=2*q+1;if(!(n.allowedPrivateKeyLengths||s===A))return b===A||b===_}function m(h,l,b=!0){if(a(h)===!0)throw new Error("first arg must be private key");if(a(l)===!1)throw new Error("second arg must be public key");return d.fromHex(l).multiply(g(h)).toRawBytes(b)}let y=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");let l=D(h),b=h.length*8-i;return b>0?l>>BigInt(b):l},v=n.bits2int_modN||function(h){return o(y(h))},I=ut(i);function U(h){return tt("num < 2^"+i,h,X,I),Q(h,s)}function Z(h,l,b=B){if(["recovered","canonical"].some(ct=>ct in b))throw new Error("sign() legacy options not supported");let{hash:q,randomBytes:A}=n,{lowS:_,prehash:C,extraEntropy:P}=b;_==null&&(_=!0),h=V("msgHash",h),Ze(b),C&&(h=V("prehashed msgHash",q(h)));let J=v(h),G=g(l),Y=[U(G),U(J)];if(P!=null&&P!==!1){let ct=P===!0?A(e.BYTES):P;Y.push(V("extraEntropy",ct))}let dt=j(...Y),rt=J;function Vt(ct){let ht=y(ct);if(!E(ht))return;let zt=u(ht),xt=d.BASE.multiply(ht).toAffine(),ft=o(xt.x);if(ft===X)return;let Et=o(zt*o(rt+ft*G));if(Et===X)return;let mt=(xt.x===ft?0:2)|Number(xt.y&k),le=Et;return _&&N(Et)&&(le=w(Et),mt^=1),new O(ft,le,mt)}return{seed:dt,k2sig:Vt}}let B={lowS:n.lowS,prehash:!1},T={lowS:n.lowS,prehash:!1};function S(h,l,b=B){let{seed:q,k2sig:A}=Z(h,l,b),_=n;return xe(_.hash.outputLen,_.nByteLength,_.hmac)(q,A)}d.BASE._setWindowSize(8);function z(h,l,b,q=T){let A=h;l=V("msgHash",l),b=V("publicKey",b);let{lowS:_,prehash:C,format:P}=q;if(Ze(q),"strict"in q)throw new Error("options.strict was renamed to lowS");if(P!==void 0&&P!=="compact"&&P!=="der")throw new Error("format must be compact or der");let J=typeof A=="string"||wt(A),G=!J&&!P&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!J&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let Y,dt;try{if(G&&(Y=new O(A.r,A.s)),J){try{P!=="compact"&&(Y=O.fromDER(A))}catch(mt){if(!(mt instanceof nt.Err))throw mt}!Y&&P!=="der"&&(Y=O.fromCompact(A))}dt=d.fromHex(b)}catch{return!1}if(!Y||_&&Y.hasHighS())return!1;C&&(l=n.hash(l));let{r:rt,s:Vt}=Y,ct=v(l),ht=u(Vt),zt=o(ct*ht),xt=o(rt*ht),ft=d.BASE.multiplyAndAddUnsafe(dt,zt,xt)?.toAffine();return ft?o(ft.x)===rt:!1}return{CURVE:n,getPublicKey:p,getSharedSecret:m,sign:S,verify:z,ProjectivePoint:d,Signature:O,utils:R}}function fn(t,n){let e=t.ORDER,r=X;for(let N=e-k;N%ot===X;N/=ot)r+=k;let s=r,i=ot<<s-k-k,c=i*ot,f=(e-k)/c,o=(f-k)/ot,u=c-k,d=i,g=t.pow(n,f),x=t.pow(n,(f+k)/ot),E=(N,w)=>{let L=g,O=t.pow(w,u),R=t.sqr(O);R=t.mul(R,w);let p=t.mul(N,R);p=t.pow(p,o),p=t.mul(p,O),O=t.mul(p,w),R=t.mul(p,N);let a=t.mul(R,O);p=t.pow(a,d);let m=t.eql(p,t.ONE);O=t.mul(R,x),p=t.mul(a,L),R=t.cmov(O,R,m),a=t.cmov(p,a,m);for(let y=s;y>k;y--){let v=y-ot;v=ot<<v-k;let I=t.pow(a,v),U=t.eql(I,t.ONE);O=t.mul(R,L),L=t.mul(L,L),I=t.mul(a,L),R=t.cmov(O,R,U),a=t.cmov(I,a,U)}return{isValid:m,value:R}};if(t.ORDER%oe===Ot){let N=(t.ORDER-Ot)/oe,w=t.sqrt(t.neg(n));E=(L,O)=>{let R=t.sqr(O),p=t.mul(L,O);R=t.mul(R,p);let a=t.pow(R,N);a=t.mul(a,p);let m=t.mul(a,w),y=t.mul(t.sqr(a),O),v=t.eql(y,L),I=t.cmov(m,a,v);return{isValid:v,value:I}}}return E}function ke(t,n){if(Zt(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let e=fn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,i,c,f,o,u,d,g;s=t.sqr(r),s=t.mul(s,n.Z),i=t.sqr(s),i=t.add(i,s),c=t.add(i,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),f=t.mul(f,n.A),i=t.sqr(c),u=t.sqr(f),o=t.mul(u,n.A),i=t.add(i,o),i=t.mul(i,c),u=t.mul(u,f),o=t.mul(u,n.B),i=t.add(i,o),d=t.mul(s,c);let{isValid:x,value:E}=e(i,u);g=t.mul(s,r),g=t.mul(g,E),d=t.cmov(d,c,x),g=t.cmov(g,E,x);let N=t.isOdd(r)===t.isOdd(g);g=t.cmov(t.neg(g),g,N);let w=yt(t,[f],!0)[0];return d=t.mul(d,w),{x:d,y:g}}}function an(t){return{hash:t,hmac:(n,...e)=>me(t,n,he(...e)),randomBytes:Tt}}function Ce(t,n){let e=r=>Le({...t,...an(r)});return{...e(n),create:e}}var un=D;function it(t,n){if(It(t),It(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);let e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function ln(t,n){let e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function It(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function dn(t,n,e,r){F(t),F(n),It(e),n.length>255&&(n=r(j(Rt("H2C-OVERSIZE-DST-"),n)));let{outputLen:s,blockLen:i}=r,c=Math.ceil(e/s);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");let f=j(n,it(n.length,1)),o=it(0,i),u=it(e,2),d=new Array(c),g=r(j(o,t,u,it(0,1),f));d[0]=r(j(g,it(1,1),f));for(let E=1;E<=c;E++){let N=[ln(g,d[E-1]),it(E+1,1),f];d[E]=r(j(...N))}return j(...d).slice(0,e)}function hn(t,n,e,r,s){if(F(t),F(n),It(e),n.length>255){let i=Math.ceil(2*r/8);n=s.create({dkLen:i}).update(Rt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(it(e,2)).update(n).update(it(n.length,1)).digest()}function Me(t,n,e){et(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:s,m:i,hash:c,expand:f,DST:o}=e;F(t),It(n);let u=typeof o=="string"?Rt(o):o,d=r.toString(2).length,g=Math.ceil((d+s)/8),x=n*i*g,E;if(f==="xmd")E=dn(t,u,x,c);else if(f==="xof")E=hn(t,u,x,s,c);else if(f==="_internal_pass")E=t;else throw new Error('expand must be "xmd" or "xof"');let N=new Array(n);for(let w=0;w<n;w++){let L=new Array(i);for(let O=0;O<i;O++){let R=g*(O+w*i),p=E.subarray(R,R+g);L[O]=M(un(p),r)}N[w]=L}return N}function Ve(t,n){let e=n.map(r=>Array.from(r).reverse());return(r,s)=>{let[i,c,f,o]=e.map(g=>g.reduce((x,E)=>t.add(t.mul(x,r),E))),[u,d]=yt(t,[c,o],!0);return r=t.mul(i,u),s=t.mul(s,t.mul(f,d)),{x:r,y:s}}}function ze(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(i){return t.fromAffine(n(i))}function s(i){let c=i.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(i,c){let f=Me(i,2,{...e,DST:e.DST,...c}),o=r(f[0]),u=r(f[1]);return s(o.add(u))},encodeToCurve(i,c){let f=Me(i,1,{...e,DST:e.encodeDST,...c});return s(r(f[0]))},mapToCurve(i){if(!Array.isArray(i))throw new Error("expected array of bigints");for(let c of i)if(typeof c!="bigint")throw new Error("expected array of bigints");return s(r(i))}}}var Nt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Lt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),fe=BigInt(0),_t=BigInt(1),kt=BigInt(2),He=(t,n)=>(t+n/kt)/n;function je(t){let n=Nt,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),o=BigInt(88),u=t*t*t%n,d=u*u*t%n,g=W(d,e,n)*d%n,x=W(g,e,n)*d%n,E=W(x,kt,n)*u%n,N=W(E,s,n)*E%n,w=W(N,i,n)*N%n,L=W(w,f,n)*w%n,O=W(L,o,n)*L%n,R=W(O,f,n)*w%n,p=W(R,e,n)*d%n,a=W(p,c,n)*N%n,m=W(a,r,n)*u%n,y=W(m,kt,n);if(!st.eql(st.sqr(y),t))throw new Error("Cannot find square root");return y}var st=At(Nt,void 0,void 0,{sqrt:je}),Mt=Ce({a:fe,b:BigInt(7),Fp:st,n:Lt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{let n=Lt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_t*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),f=He(i*t,n),o=He(-r*t,n),u=M(t-f*e-o*s,n),d=M(-f*r-o*i,n),g=u>c,x=d>c;if(g&&(u=n-u),x&&(d=n-d),u>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:g,k1:u,k2neg:x,k2:d}}}},vt),Pe={};function Ct(t,...n){let e=Pe[t];if(e===void 0){let r=vt(Uint8Array.from(t,s=>s.charCodeAt(0)));e=j(r,r),Pe[t]=e}return vt(j(e,...n))}var ae=t=>t.toRawBytes(!0).slice(1),se=t=>Q(t,32),ie=t=>M(t,Nt),qt=t=>M(t,Lt),ue=Mt.ProjectivePoint,mn=(t,n,e)=>ue.BASE.multiplyAndAddUnsafe(t,n,e);function ce(t){let n=Mt.utils.normPrivateKeyToScalar(t),e=ue.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:qt(-n),bytes:ae(e)}}function Ke(t){tt("x",t,_t,Nt);let n=ie(t*t),e=ie(n*t+BigInt(7)),r=je(e);r%kt!==fe&&(r=ie(-r));let s=new ue(t,r,_t);return s.assertValidity(),s}var bt=D;function Ye(...t){return qt(bt(Ct("BIP0340/challenge",...t)))}function wn(t){return ce(t).bytes}function gn(t,n,e=Tt(32)){let r=V("message",t),{bytes:s,scalar:i}=ce(n),c=V("auxRand",e,32),f=se(i^bt(Ct("BIP0340/aux",c))),o=Ct("BIP0340/nonce",f,s,r),u=qt(bt(o));if(u===fe)throw new Error("sign failed: k is zero");let{bytes:d,scalar:g}=ce(u),x=Ye(d,s,r),E=new Uint8Array(64);if(E.set(d,0),E.set(se(qt(g+x*i)),32),!De(E,r,s))throw new Error("sign: Invalid signature produced");return E}function De(t,n,e){let r=V("signature",t,64),s=V("message",n),i=V("publicKey",e,32);try{let c=Ke(bt(i)),f=bt(r.subarray(0,32));if(!at(f,_t,Nt))return!1;let o=bt(r.subarray(32,64));if(!at(o,_t,Lt))return!1;let u=Ye(se(f),ae(c),s),d=mn(c,o,qt(-u));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}var Kn={getPublicKey:wn,sign:gn,verify:De,utils:{randomPrivateKey:Mt.utils.randomPrivateKey,lift_x:Ke,pointToBytes:ae,numberToBytesBE:Q,bytesToNumberBE:D,taggedHash:Ct,mod:M}},pn=Ve(st,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),yn=ke(st,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:st.create(BigInt("-11"))}),We=ze(Mt.ProjectivePoint,t=>{let{x:n,y:e}=yn(st.create(t[0]));return pn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:st.ORDER,m:1,k:128,expand:"xmd",hash:vt}),Yn=We.hashToCurve,Dn=We.encodeToCurve;export{Dn as encodeToCurve,Yn as hashToCurve,Kn as schnorr,Mt as secp256k1,We as secp256k1_hasher};
