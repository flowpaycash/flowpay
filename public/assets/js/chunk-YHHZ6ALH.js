import{c}from"./chunk-PO2OHKQD.js";import{B as g,p as u,q as v,r as w,s,t as l,u as a}from"./chunk-MKYDMTOZ.js";import{a as d}from"./chunk-W44JATXS.js";function f(i){return(e,r,t,n)=>e.method==="chainId"?(r.result=i,n()):t()}function E(i){return(e,r,t,n)=>e.method==="provider_config"?(r.result=i,n()):t()}function P(i){let{chainId:e,rpcTarget:r}=i,t=g({rpcTarget:r});return{networkMiddleware:l([f(e),E(i),t]),fetchMiddleware:t}}var y,h=class extends c{constructor({config:e,state:r}){super({config:e,state:r})}async setupProvider(e){let r=this.getChain(e);if(!r)throw u.custom({message:"Chain not found",code:4902});let{networkMiddleware:t}=P(r),n=new s;n.push(t);let o=a(n);this.updateProviderEngineProxy(o),this.emit("chainChanged",e),this.emit("connect",{chainId:e}),this.update({chainId:e})}async switchChain(e){if(!this._providerEngineProxy)throw u.custom({message:"Provider is not initialized",code:4902});let r=e.chainId;this.chainId!==r&&(this.update({chainId:"loading"}),await this.setupProvider(r))}getProviderEngineProxy(){return this._providerEngineProxy}lookupNetwork(){throw new Error("Method not implemented.")}};y=h;d(h,"getProviderInstance",async i=>{let e=new y({config:{chain:i.chain,chains:i.chains}}),{chainId:r}=i.chain;return await e.setupProvider(r),e});var m,p=class extends c{constructor({config:e,state:r}){super({config:e,state:r}),d(this,"_providerEngineProxy",null)}get provider(){return this._providerEngineProxy}set provider(e){throw new Error("Method not implemented.")}async setupProvider(e){let r=this.getPrivKeyMiddleware(e),t=new s;t.push(r);let n=a(t);this.updateProviderEngineProxy(n)}async switchChain(e){return Promise.resolve()}getProviderEngineProxy(){return this._providerEngineProxy}async lookupNetwork(){return Promise.resolve("")}getPrivKeyMiddleware(e){let r={getPrivatekey:async()=>{if(!this.config.keyExportEnabled)throw new Error("Exporting private key is disabled. Please enable it in the provider config");return e}};return this.createPrivKeyMiddleware(r)}createPrivKeyMiddleware({getPrivatekey:e}){async function r(t,n){try{n.result=await e()}catch(o){n.error=o instanceof Error?o.message:o}}return v({private_key:w(r)})}};m=p;d(p,"getProviderInstance",async i=>{let e=new m({config:{chain:i.chain,chains:i.chains}});return await e.setupProvider(i.privKey),e});export{h as a,p as b};
